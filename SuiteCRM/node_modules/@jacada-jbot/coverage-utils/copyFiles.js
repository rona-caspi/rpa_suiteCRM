const fs = require('fs');
const CURR_DIR = process.cwd();

// Merging the extended elements metadata with ours where ours is dominate
console.log("Merging elementsMetadata");
let extendedJson = {};
if (fs.existsSync(`${CURR_DIR}/elementsMetadata/extended.json`)){
	extendedJson = JSON.parse(fs.readFileSync(`${CURR_DIR}/elementsMetadata/extended.json`, 'utf8'));
}
let thisJson = {};
if (fs.existsSync(`${CURR_DIR}/elementsMetadata/this.json`)){
	thisJson = JSON.parse(fs.readFileSync(`${CURR_DIR}/elementsMetadata/this.json`, 'utf8'));
}
let mergedJson = mergeJSON(extendedJson, thisJson);

// saving the elementsMetadata merged one
let mergedJsonStr = JSON.stringify(mergedJson, null, 2);
fs.writeFileSync(`${CURR_DIR}/elementsMetadata/elementsMetadata.json`, mergedJsonStr);
if (fs.existsSync(`${CURR_DIR}/export`)){
	fs.writeFileSync(`${CURR_DIR}/export/elementsMetadata.json`, mergedJsonStr);
}

// Merge the out and interfaces to the include folder
console.log("Merging ts and js into include folder");
if (fs.existsSync(`${CURR_DIR}/include`)){
    deleteAllFiles(`${CURR_DIR}/include`);
} else {
	fs.mkdirSync(`${CURR_DIR}/include`);
}

copyFiles (`${CURR_DIR}/out`, `${CURR_DIR}/include`);
copyFiles (`${CURR_DIR}/interfaces`, `${CURR_DIR}/include`);
copyFiles (`${CURR_DIR}/src`, `${CURR_DIR}/include`,".d.ts");	// Copy declared interfaces

if (fs.existsSync(`${CURR_DIR}/export`)){
	console.log("Copy Coverage Handler JS file");
	copyFiles (`${CURR_DIR}/dist`, `${CURR_DIR}/export`);
	// Update the manifest file from package.json
	updateExportManifest();
}

function isPlainObject(o) {    
	var c = Object.prototype.toString.call(o) == '[object Object]'
			&& o.constructor && o.constructor.name=="Object";
	return c === true;
}

var jsonC = {}.constructor ;

function isJSON (json){
	if (json && json.constructor === jsonC){
		return true ;
	} else {
		return isPlainObject(json) ;
	}
} ;

function cloneJSON (data){
	return mergeJSON({}, data) ;
} ;

function mergeJSON (json1, json2){
	var result = null ;
	if (isJSON(json2)){
		result = {} ;
		if (isJSON(json1)){
			for (var key in json1){
				if (isJSON(json1[key]) || Array.isArray(json1[key])) {
					result[key] = cloneJSON(json1[key]) ;
				} else {
					result[key] = json1[key];
				}
			}
		}

		for (var key in json2){
			if (isJSON(json2[key]) || Array.isArray(json2[key])){
				result[key] = mergeJSON(result[key], json2[key]) ;
			} else {
				result[key] = json2[key] ;
			}
		}
	} else if (Array.isArray(json1) && Array.isArray(json2)){
		result = json1 ;

		for (var i = 0; i < json2.length; i++){
			if (result.indexOf(json2[i]) === -1){
				result[result.length] = json2[i] ;
			}
		}
	} else {
		result = json2 ;
	}

	return result ;
} ;

function updateExportManifest(){
	let appPackageJsonFileName = `${CURR_DIR}/package.json`;
	let exportManifestJsonFileName = `${CURR_DIR}/export/manifest.json`;

	let appPackageJson = JSON.parse(fs.readFileSync(appPackageJsonFileName, 'utf8'));
	let exportManifestJson = JSON.parse(fs.readFileSync(exportManifestJsonFileName, 'utf8'));

  // Update the file
  exportManifestJson.name = appPackageJson.name.replace("@jacada-jbot/","");
  exportManifestJson.version = appPackageJson.version;
  exportManifestJson.description = appPackageJson.description;
	exportManifestJson.createdBy = appPackageJson.author;
	
  // The , null, 2 at the end of the stringidy make sure it's readable
  let exportManifestJsonStr = JSON.stringify(exportManifestJson, null, 2);
  // write the manifest json file.
  fs.writeFileSync(exportManifestJsonFileName, exportManifestJsonStr);

}

function deleteAllFiles (path) {
    try {
        const filesToDelete  = fs.readdirSync(path);
  
        filesToDelete.forEach(file => {
          const origFilePath = `${path}/${file}`;
          
          // get stats about the current file
          const stats = fs.statSync(origFilePath);
      
          if (stats.isFile()) {
            fs.unlinkSync(origFilePath);
          } else if (stats.isDirectory()) {
            // recursive call
            deleteAllFiles(origFilePath);
            fs.rmdirSync(origFilePath);
          }
        });
    } catch (e){
        console.log("Exception while deleting files in " + path, e);
    }
}
  
function copyFiles (fromPath, toPath, extension) {
	const filesToCreate = fs.readdirSync(fromPath);
  
    filesToCreate.forEach(file => {
      const origFilePath = `${fromPath}/${file}`;
      
      // get stats about the current file
      const stats = fs.statSync(origFilePath);
  
      if (stats.isFile()) {
				if (extension){
					if (!file.endsWith(extension)){
						return true;		// Continue to next file
					}
				}

				const contents = fs.readFileSync(origFilePath, 'utf8');
        
        const writePath = `${toPath}/${file}`;
        fs.writeFileSync(writePath, contents, 'utf8');
      } else if (stats.isDirectory()) {
				if (!fs.existsSync(`${toPath}/${file}`)){
					fs.mkdirSync(`${toPath}/${file}`);
				}
        
        // recursive call
        copyFiles(`${fromPath}/${file}`, `${toPath}/${file}`, extension);
      }
    });
}
  