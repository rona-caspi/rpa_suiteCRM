"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var GenericResult_1 = require("./GenericResult");
var Constants_1 = require("./Constants");
var Log4jConfig_1 = require("../Utils/Log4jConfig");
var log = Log4jConfig_1.logFactory.getLogger("RepositoryHandler");
/**
 * This class represents the repository handler
 */
var RepositoryHandler = /** @class */ (function () {
    /*
     * The RepositoryHandler contains the repository and point to the current node in the repository.
    */
    function RepositoryHandler(repository, currentNode, parentHandler) {
        this._pathId = null;
        this._parentHandler = null;
        this._repository = repository;
        if (currentNode) {
            this._currentNode = currentNode;
        }
        else {
            this._currentNode = repository.tree; // Default is the top of the tree
        }
        this._parentHandler = parentHandler;
        if (parentHandler) {
            this.createPath(parentHandler.pathId, this.id);
        }
        else {
            this.createPath(null, this.id);
        }
    }
    Object.defineProperty(RepositoryHandler.prototype, "repository", {
        // Note: Elements in the tree which start with _ have precedents on same names without underscore. They are usually added manually and the record/capture doesn't override them
        /**
         * Points to the repository
         */
        get: function () { return this._repository; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RepositoryHandler.prototype, "repositoryTree", {
        get: function () { return this._repository.tree; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RepositoryHandler.prototype, "currentNode", {
        get: function () { return this._currentNode; },
        /**
         * Points to the current node in the repository
         */
        set: function (node) { this._currentNode = node; },
        enumerable: false,
        configurable: true
    });
    ;
    ;
    Object.defineProperty(RepositoryHandler.prototype, "pathId", {
        get: function () { return this._pathId; },
        /**
         * Points to the path id of the element
         */
        set: function (id) { this._pathId = id; },
        enumerable: false,
        configurable: true
    });
    ;
    ;
    Object.defineProperty(RepositoryHandler.prototype, "parentHandler", {
        get: function () { return this._parentHandler; },
        set: function (parentHandler) { this._parentHandler = parentHandler; },
        enumerable: false,
        configurable: true
    });
    ;
    ;
    Object.defineProperty(RepositoryHandler.prototype, "name", {
        get: function () { return this.currentNode._name ? this.currentNode._name : this.currentNode.name; },
        set: function (name) { this.currentNode.name = name; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RepositoryHandler.prototype, "id", {
        // In case there is no id, we use the name.
        get: function () { return this.currentNode._id ? this.currentNode._id : (this.currentNode.id ? this.currentNode.id : this.name); },
        set: function (id) { this.currentNode.id = id; },
        enumerable: false,
        configurable: true
    });
    /**
     * This method gets the id of the node.
     * @param node
     * @returns
     */
    RepositoryHandler.prototype.getNodeId = function (node) {
        return node._id ? node._id : (node.id ? node.id : (node._name ? node._name : node.name));
    };
    Object.defineProperty(RepositoryHandler.prototype, "coverageHandlerName", {
        get: function () { return this.currentNode._coverageHandler ? this.currentNode._coverageHandler : this.currentNode.coverageHandler; },
        set: function (coverageHandler) { this.currentNode.coverageHandler = coverageHandler; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RepositoryHandler.prototype, "type", {
        get: function () { return this.currentNode._type ? this.currentNode._type : this.currentNode.type; },
        /**
         * The type of the node
         */
        set: function (type) { this.currentNode.type = type; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RepositoryHandler.prototype, "children", {
        get: function () { return this.currentNode._children ? this.currentNode._children : this.currentNode.children; },
        /**
         * Points to the children of the node
         */
        set: function (children) { this.currentNode.children = children; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RepositoryHandler.prototype, "config", {
        get: function () { return this.currentNode._config ? this.currentNode._config : this.currentNode.config; },
        /**
         * The config section
         */
        set: function (config) { this.currentNode.config = config; },
        enumerable: false,
        configurable: true
    });
    /**
     * This method finds an element in the repository by its id.
     * @param lElelementId
     * @returns the element found
     */
    RepositoryHandler.prototype.findElementByIdInCurrent = function (lElelementId) {
        // Find the element in the repository
        var subNodeElements = this.getSubNodesOfCurrent();
        for (var _i = 0, subNodeElements_1 = subNodeElements; _i < subNodeElements_1.length; _i++) {
            var subNodeElement = subNodeElements_1[_i];
            var nodeId = this.getNodeId(subNodeElement);
            if (nodeId && nodeId === lElelementId)
                return subNodeElement;
        }
        ;
        return null;
    };
    /**
     * This method finds an element in the repository by the config section.
     * @param lConfig
     * @returns the element found
     */
    RepositoryHandler.prototype.findElementByConfigInCurrent = function (lConfig) {
        // Find the element in the repository by the config
        var sConfig = JSON.stringify(lConfig); // We compare json strings
        var subNodeElements = this.getSubNodesOfCurrent();
        for (var _i = 0, subNodeElements_2 = subNodeElements; _i < subNodeElements_2.length; _i++) {
            var subNodeElement = subNodeElements_2[_i];
            if (subNodeElement.config && JSON.stringify(subNodeElement.config) === sConfig)
                return subNodeElement;
        }
        ;
        return null;
    };
    /**
     * Points to the application on the repository
     * @returns
     */
    RepositoryHandler.prototype.applicationHandler = function () {
        if (this.parentHandler) {
            return this.parentHandler.applicationHandler();
        }
        else {
            return this;
        }
    };
    /**
     * This method get all the sub nodes of the current element.
     * @returns
     */
    RepositoryHandler.prototype.getSubNodesOfCurrent = function () {
        if (this.children)
            return this.children;
        // GDTEMP: Need to support other hierarchies. Is it by defining different repository handler?? Is it by the current coverage handler?
        return [];
    };
    /**
     * This method adds the given node the children in the repository.
     * @param subNode
     */
    RepositoryHandler.prototype.addNodeToChildren = function (subNode) {
        var subNodeElements = this.getSubNodesOfCurrent();
        subNodeElements.push(subNode);
    };
    /**
     * This method removes the given node from the children in the repository
     * @param {*} subNode - the node to remove
     * @memberof RepositoryHandler
     */
    RepositoryHandler.prototype.removeNodeFromChildren = function (subNode) {
        var subNodeElements = this.getSubNodesOfCurrent();
        var index = 0;
        for (var _i = 0, subNodeElements_3 = subNodeElements; _i < subNodeElements_3.length; _i++) {
            var child = subNodeElements_3[_i];
            var subNodeId = this.getNodeId(subNode);
            var childNodeId = this.getNodeId(child);
            if (subNodeId && childNodeId && subNodeId === childNodeId) {
                //delete this.currentNode["children"][index];// subNodeElements[child];
                this.currentNode["children"].splice(index, 1);
                break;
            }
            else {
                var subNodeConfig = JSON.stringify(subNode.config);
                if (child.config && JSON.stringify(child.config) === subNodeConfig) {
                    //delete this.currentNode["children"][index];
                    this.currentNode["children"].splice(index, 1);
                    break;
                }
            }
            index++;
        }
    };
    /**
     * TODO RONA: why is it here? should we remove it?
     * @param errorMessage
     * @returns
     */
    RepositoryHandler.prototype.returnFailure = function (errorMessage) {
        log.error(errorMessage);
        return new GenericResult_1.GenericResult(false, errorMessage, null);
    };
    /**
     * TODO RONA: why is it here? should we remove it?
     * @param data
     * @returns
     */
    RepositoryHandler.prototype.returnSuccess = function (data) {
        return new GenericResult_1.GenericResult(true, null, data);
    };
    /**
     * This method creates a path to the element
     * @param basePath
     * @param elementName
     * @returns a string representing the path to the element
     */
    RepositoryHandler.prototype.createPath = function (basePath, elementName) {
        log.debug("CreatePath Base path:" + basePath + " element name:" + elementName);
        if (basePath) {
            if (basePath.length > 0)
                basePath = basePath + Constants_1.Constants.ELEMENT_PATH_IDS;
            this.pathId = basePath + elementName;
        }
        else {
            this.pathId = elementName;
        }
        log.debug("Path:" + this.pathId);
        return this.pathId;
    };
    /**
     * This method merges two paths together.
     * @param path1
     * @param path2
     * @returns the merged path
     */
    RepositoryHandler.prototype.mergePaths = function (path1, path2) {
        log.debug("mergePaths path1:" + path1 + " path2:" + path2);
        if (path1 && path1.length > 0) {
            if (path2 && path2.length > 0) {
                return path1 + Constants_1.Constants.ELEMENT_PATH_IDS + path2;
            }
            else {
                return path1;
            }
        }
        else {
            return path2;
        }
    };
    /**
     * This method gets the path of the element concatenated with its name.
     * @param elementName
     * @returns the concatenated string
     */
    RepositoryHandler.prototype.getPathWithElement = function (elementName) {
        log.debug("getPathWithElement path id " + this.pathId + " element name " + elementName);
        var pathId = this.pathId;
        if (!pathId)
            return elementName;
        if (pathId.length > 0)
            pathId = pathId + Constants_1.Constants.ELEMENT_PATH_IDS;
        return pathId + elementName;
    };
    return RepositoryHandler;
}());
exports.default = RepositoryHandler;
//# sourceMappingURL=RepositoryHandler.js.map