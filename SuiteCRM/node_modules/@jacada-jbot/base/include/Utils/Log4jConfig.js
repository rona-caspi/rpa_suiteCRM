"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomLogger = exports.Logging = exports.logFactory = void 0;
var typescript_logging_1 = require("typescript-logging");
var options = new typescript_logging_1.LoggerFactoryOptions()
    .addLogGroupRule(new typescript_logging_1.LogGroupRule(new RegExp(".+"), typescript_logging_1.LogLevel.Trace, new typescript_logging_1.LogFormat(), typescript_logging_1.LoggerType.Custom, function (name, settings) { return new CustomLogger(name, settings); }));
// Create a named loggerfactory and pass in the options and export the factory.
// Named is since version 0.2.+ (it's recommended for future usage)
exports.logFactory = typescript_logging_1.LFService.createNamedLoggerFactory("LoggerFactory", options);
exports.Logging = {
    help: typescript_logging_1.help,
    getLogControl: typescript_logging_1.getLogControl,
    getCategoryControl: typescript_logging_1.getCategoryControl,
};
var CustomLogger = /** @class */ (function (_super) {
    __extends(CustomLogger, _super);
    function CustomLogger(name, settings) {
        return _super.call(this, name, settings) || this;
    }
    CustomLogger.prototype.doLog = function (msg) {
        var formattedMessage = this.createDefaultLogMessage(msg);
        if (CustomLogger.ourLogger) {
            var loglevel = typescript_logging_1.LogLevel[msg.level];
            CustomLogger.ourLogger[loglevel]("[" + CustomLogger.applicationName + "] " + msg.loggerName + ": " + msg.message);
        }
        else {
            console.log(formattedMessage);
        }
    };
    CustomLogger.setLogLevel = function (logLevel) {
        var logLevelAsString = this.getLogLevelAsString(logLevel);
        typescript_logging_1.getLogControl().getLoggerFactoryControl(0).change({ group: "all", logLevel: logLevelAsString, logFormat: "Default", showLoggerName: true, showTimestamp: false });
    };
    CustomLogger.setApplicationName = function (applicationName) {
        CustomLogger.applicationName = applicationName;
    };
    CustomLogger.getLogLevelAsString = function (logLevel) {
        switch (logLevel) {
            case 0:
                return "Trace";
            case 1:
                return "Debug";
            case 2:
                return "Info";
            case 3:
                return "Warn";
            case 4:
                return "Error";
            case 5:
                return "Fatal";
            default:
                return undefined;
        }
    };
    return CustomLogger;
}(typescript_logging_1.AbstractLogger));
exports.CustomLogger = CustomLogger;
//# sourceMappingURL=Log4jConfig.js.map