"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var GenericResult_1 = require("../Model/GenericResult");
var RepositoryHandler_1 = require("../Model/RepositoryHandler");
var ElementData_1 = require("../Model/ElementData");
var Constants_1 = require("../Model/Constants");
// The Coverage Handler is in the root level of all CoverageHandlers.
// The Hierarchy is something like that:
//
//  - CoverageHandler
//      - ApplicationCoverageHandler
//          - WebApplicationCoverageHandler
//              - WebApplicationCoverageHandler
//          - WinApplicationCoverageHandler
//      - ControlCoverageHandler
//          - ScreenCoverageHandler
//              - WebScreenCoverageHandler
//              - WinScreenCoverageHandler
//          - WebControlCoverageHandler
//              - TextInputWebControlCoverageHandler
//              - DropdownWebControlCoverageHandler
//              - ComboBoxWebControlCoverageHandler
//              - RadioGroupWebControlCoverageHandler
//              - ButtonWebControlCoverageHandler
//              - ImageWebControlCoverageHandler
//                  - TableWebControlCoverageHandler
//          - WinControlCoverageHandler
//
//
//   Each CoverageHandler has the Platform Driver which is responsible for the actual connection to the screen such as IEPlatformDriver.
//   It contains the repository with a cursor inside that tells on which element it points now and the current data we save for this application.
//
//   From data prospective, every CoverageHandler points to it's parent while the parent can get to the CH based on the PathId.
var Log4jConfig_1 = require("../Utils/Log4jConfig");
var log = Log4jConfig_1.logFactory.getLogger("CoverageHandler");
var CoverageHandler = /** @class */ (function () {
    function CoverageHandler(platformDriver, repositoryHandler, applicationData, parentCoverageHandler, factory, applicationCoverageHandler) {
        if (applicationCoverageHandler === void 0) { applicationCoverageHandler = null; }
        this.platformDriver = platformDriver;
        this.repositoryHandler = repositoryHandler;
        this.applicationData = applicationData;
        this.parentCoverageHandler = parentCoverageHandler;
        this.applicationCoverageHandler = applicationCoverageHandler;
        this.factory = factory;
    }
    /**
     * This method executes the action received on the related element.
     * @param lElementPathId - the path to the element
     * @param lAction - a struct holding the action name and a list of values, when needed
     * @returns a GenericResult struct with the action result in the data
     */
    CoverageHandler.prototype.executeAction = function (lElementPathId, lAction) {
        return this.returnFailure("executeAction Need to be inherited");
    };
    /**
     * This method executes the action received on the related element.
     * @param lElementPathId - the path to the element
     * @param lAction - a struct holding the action name and a list of values, when needed
     * @returns a GenericResult struct with the action result in the data
     */
    CoverageHandler.prototype.executeActionAsync = function (lElementPathId, lAction) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.returnFailure("executeAction Need to be inherited")];
            });
        });
    };
    /**
     * This method starts the recording process.
     * @returns a GenericResult struct
     */
    CoverageHandler.prototype.startRecording = function () {
        return this.returnFailure("startRecording Need to be inherited");
    };
    /**
     * This method stops the recording process.
     * @returns a GenericResult struct
     */
    CoverageHandler.prototype.stopRecording = function () {
        return this.returnFailure("stopRecording Need to be inherited");
    };
    /**
     * This method starts the capturing process.
     * @returns a GenericResult
     */
    CoverageHandler.prototype.startCapturing = function () {
        return this.returnFailure("startCapturing Need to be inherited");
    };
    /**
     * This method stops the capturing process.
     * @returns a GenericResult struct
     */
    CoverageHandler.prototype.stopCapturing = function () {
        return this.returnFailure("stopCapturing Need to be inherited");
    };
    /**
     * This method starts the listening process.
     * @returns a GenericResult struct
     */
    CoverageHandler.prototype.startListening = function () {
        return this.returnFailure("startListening Need to be inherited");
    };
    /**
     * This method stops the listening process.
     * @returns a GenericResult struct
     */
    CoverageHandler.prototype.stopListening = function () {
        return this.returnFailure("stopListening Need to be inherited");
    };
    /**
     * This method iterates on the parentNodes' children and on each child it performs the func function.
     * @param parentNode - the node to iterate its children on.
     * @param func - the function that will be execute on each child
     */
    CoverageHandler.prototype.walkOnChildren = function (parentNode, func) {
        log.debug("This method should be inherited");
    };
    /**
     * This method registers the element for highlighting (for recording and capturing process), it sets it in the highlightMap.
     * @param controlCoverageHandler - the elements' coverageHandler
     * @param elem - the node
     * @param functionHandler - the callback function to call in case we are in capturing mode.
     */
    CoverageHandler.prototype.registerControlForHighlight = function (controlCoverageHandler, elem, functionHandler) {
        log.debug("This needs to be inherited");
    };
    // public elementId(): string {
    //     if (this.repositoryHandler) {
    //         return this.repositoryHandler.id;
    //     } else {
    //         return null;
    //     }
    // }
    /**
     * This method sets a GenericResult struct with failure value, and an error message.
     * @param errorMessage
     * @returns a GenericResult struct with failure value.
     */
    CoverageHandler.prototype.returnFailure = function (errorMessage) {
        log.error(errorMessage);
        return new GenericResult_1.GenericResult(false, errorMessage, null);
    };
    /**
     * This method sets a GenericResult struct with success value, and data.
     * @param data
     * @returns  a GenericResult struct with success value.
     */
    CoverageHandler.prototype.returnSuccess = function (data) {
        return new GenericResult_1.GenericResult(true, null, data);
    };
    /**
     * This method creates a coverageHandler for the element, using the defaultCoverageHandlerFunction in case it doesn't exist yet, or return it
     * if it is already exist.
     * @param repositoryHandler - the repositoryHandler holds the path to the element
     * @param parentCoverageHandler
     * @param defaultCoverageHandlerFunction - the default function to create a coverageHandler
     * @returns a GenericResult struct with the coverageHandler inside the data.
     */
    CoverageHandler.prototype.getElementCoverageHandler = function (repositoryHandler, parentCoverageHandler, defaultCoverageHandlerFunction) {
        // We save the coverage handler object in the applicationData based on the pathId of the element (should be full)
        var pathId = repositoryHandler.pathId;
        var elementData = this.pathIdToTemporaryElementData(pathId);
        if (elementData.coverageHandler) {
            log.trace("elementData.coverageHandler: " + elementData.coverageHandler.constructor.name);
            // Update the repository handler as conceptually, it might have changed (manually)
            log.trace("Reusing coverage handler for path " + pathId);
            elementData.coverageHandler.repositoryHandler = repositoryHandler;
        }
        else {
            if (repositoryHandler.coverageHandlerName) {
                // Coverage Handler Name is indicated on the node?
                elementData.coverageHandler = new CoverageHandler[repositoryHandler.coverageHandlerName](this.platformDriver, repositoryHandler, this.applicationData, parentCoverageHandler, this.applicationCoverageHandler);
            }
            else {
                if (defaultCoverageHandlerFunction) {
                    elementData.coverageHandler = defaultCoverageHandlerFunction(parentCoverageHandler, repositoryHandler);
                }
                else {
                    elementData.coverageHandler = null;
                }
            }
        }
        var resultData = {
            coverageHandler: elementData.coverageHandler,
        };
        return this.returnSuccess(resultData);
    };
    /**
     * TODO RONA : change name?
     * This method returns a struct holding coverageHandler for the element, that was stored in applicationData field.
     * In case there still isn't a stored coverageHandler, it creates an empty struct.
     * @param pathId - the path of the element
     * @returns a ElementData struct that holds the coverageHandler.
     */
    CoverageHandler.prototype.pathIdToTemporaryElementData = function (pathId) {
        var elementData = this.applicationData.getScreenTopicData(Constants_1.Constants.ELEMENT_DATA_TOPIC, pathId);
        if (!elementData) {
            elementData = new ElementData_1.default();
            this.applicationData.setScreenTopicData(Constants_1.Constants.ELEMENT_DATA_TOPIC, pathId, elementData);
        }
        return elementData;
    };
    /**
     * This method stores the coverageHandler in applicationData field using the uniqueId as the key.
     * @param uniqueId
     */
    CoverageHandler.prototype.saveCoverageHandlerForUniqueId = function (uniqueId) {
        var elemData = new ElementData_1.default();
        elemData.coverageHandler = this;
        this.applicationData.setScreenTopicData(Constants_1.Constants.ELEMENT_DATA_TOPIC, uniqueId, elemData);
    };
    /**
     * This method deletes the coverageHandler stored in applicationData field using the uniqueId as the key.
     * @param uniqueId
     */
    CoverageHandler.prototype.deleteCoverageHandlerForUniqueId = function (uniqueId) {
        this.applicationData.deleteScreenTopicData(Constants_1.Constants.ELEMENT_DATA_TOPIC, uniqueId);
    };
    /**
     * This method gets the coverageHandler stored in applicationData field by the uniqueId.
     * @param uniqueId
     * @returns the coverageHandler
     */
    CoverageHandler.prototype.fetchCoverageHandlerFromUniqueId = function (uniqueId) {
        var elementData = this.applicationData.getScreenTopicData(Constants_1.Constants.ELEMENT_DATA_TOPIC, uniqueId);
        if (elementData) {
            return elementData.coverageHandler;
        }
        else {
            return null;
        }
    };
    /**
     * This method deletes all the data stored in the applicationData field.
     */
    CoverageHandler.prototype.deleteAllElementDataTopic = function () {
        this.applicationData.deleteScreenTopic(Constants_1.Constants.ELEMENT_DATA_TOPIC);
    };
    /**
     * This method gets a control type and returns the suitable coverageHandler.
     * @param controlType
     * @returns a GenericResult struct with the coverageHandler inside the data
     */
    CoverageHandler.prototype.getCoverageHandlerByNode = function (node) {
        // Need to have the right handler and from it the id. We then might need to change to another coverage handler.
        // is the default control coverage indicated in the repository on this node?
        var coverageHandler = this.factory.createCoverageHandlerByNode(this.platformDriver, null, this.applicationData, this, node, this.factory, this.applicationCoverageHandler);
        return this.returnSuccess({ coverageHandler: coverageHandler });
    };
    /**
     * This method gets the repository for an element that is the next on the path.
     * @param elementPath
     * @returns a GenericResult struct with the repositoryHandler inside the data
     */
    CoverageHandler.prototype.getNextPathRepository = function (elementPath) {
        // Advance to next and find the element in the current repository element
        var result = this.getNextPathElement(elementPath);
        if (!result.success)
            return result;
        var nodeElement = result.data.nodeElement;
        // Create a repository handler for the screen
        var fullPathId = elementPath.currentFullPathId();
        log.trace("Getting next repository for: " + fullPathId);
        var nextRepositoryHandler = this.createRepositoryForNode(nodeElement, fullPathId);
        if (!nextRepositoryHandler)
            return this.returnFailure("Failed creating next repository.");
        return this.returnSuccess({ repositoryHandler: nextRepositoryHandler });
    };
    /**
     * This method gets the repository for an element that is the next on the path, and creates a coverageHandler
     * @param elementPath
     * @returns a GenericResult struct with the coverageHandler inside the data
     */
    CoverageHandler.prototype.getCoverageHandlerByNextPath = function (elementPath) {
        // Move to next element in path
        // Get it and its repository
        var result = this.getNextPathRepository(elementPath);
        if (!result.success)
            return new GenericResult_1.GenericResult(false, "Could not find element " + elementPath._elementPathId + " in repository", Constants_1.Constants.ELEMENT_NOT_FOUND_EXCEPTION);
        var elementRepositoryHandler = result.data.repositoryHandler;
        var resultData = {
            coverageHandler: this.factory.createCoverageHandlerByType(this.platformDriver, elementRepositoryHandler, this.applicationData, this, this.factory, elementRepositoryHandler.currentNode.type, this.applicationCoverageHandler),
        };
        // Get the element coverage handler
        return this.returnSuccess(resultData);
    };
    /**
     * This method gets the element that is next on the pathId.
     * @param elementPath
     * @returns a GenericResult struct with the element inside the data
     */
    CoverageHandler.prototype.getNextPathElement = function (elementPath) {
        // Advance to next element
        var nodeId = elementPath.next();
        if (nodeId === null)
            return this.returnFailure("No screen id in element path");
        // Find the element in the current repository element
        log.trace("Searching for " + nodeId + " in current repository");
        var nodeElement = this.repositoryHandler.findElementByIdInCurrent(nodeId);
        if (!nodeElement)
            return this.returnFailure("Path Element " + nodeId + " not found.");
        return this.returnSuccess({ nodeElement: nodeElement });
    };
    /**
     * This method finds an element by its Id in the repository.
     * @param lElementId
     * @returns the element found, or null.
     */
    CoverageHandler.prototype.findElementByIdInCurrent = function (lElementId) {
        if (this.repositoryHandler) {
            return this.repositoryHandler.findElementByIdInCurrent(lElementId);
        }
        else {
            return null;
        }
    };
    /**
     * This method creates a repositoryHandler for the given element and pathId.
     * @param nodeElement
     * @param pathId
     * @returns the created repositoryHandler.
     */
    CoverageHandler.prototype.createRepositoryForNode = function (nodeElement, pathId) {
        // Create another repository handler, this time with different 'current'
        var elementRepositoryHandler = new RepositoryHandler_1.default(this.repositoryHandler.repository, nodeElement, this.repositoryHandler);
        // Setting the element fullPath Id
        elementRepositoryHandler.pathId = pathId;
        return elementRepositoryHandler;
    };
    /**
     * This method gets a coverageHandler by its type.
     * @param me
     * @param repositoryHandler
     * @returns the coverageHandler.
     */
    CoverageHandler.prototype.coverageHandlerByType = function (me, repositoryHandler) {
        return this.getCoverageHandlerByTypeInRepository(repositoryHandler, me, repositoryHandler.currentNode.type);
    };
    /**
     * This method gets a coverageHandler by its type in the repository.
     * @param repositoryHandler
     * @param me
     * @param controlType
     * @returns the coverageHandler.
     */
    CoverageHandler.prototype.getCoverageHandlerByTypeInRepository = function (repositoryHandler, me, controlType) {
        var coverageHandler;
        coverageHandler = this.factory.createCoverageHandlerByType(this.platformDriver, repositoryHandler, this.applicationData, this, this.factory, controlType, this.applicationCoverageHandler);
        return coverageHandler;
    };
    /**
     * This method creates the element coverageHandler according to the elementPath
     * @param elementPath - the repository path of the element
     * @returns a GenericResult with the coverageHandler created inside the data
     */
    CoverageHandler.prototype.getCoverageHandlerByNextPathInRepository = function (elementPath) {
        // Move to next element in path
        // Get it and its repository
        var result = this.getNextPathRepository(elementPath);
        if (!result.success)
            return new GenericResult_1.GenericResult(false, "Could not find element " + elementPath._elementPathId + " in repository", Constants_1.Constants.ELEMENT_NOT_FOUND_EXCEPTION);
        var elementRepositoryHandler = result.data.repositoryHandler;
        // Get the element coverage handler
        result = this.getElementCoverageHandler(elementRepositoryHandler, this, this.coverageHandlerByType.bind(this));
        return result;
    };
    /**
     * This method is digging down all the way to the requested element on the elementPath for listening.
     * @param elementPath
     * @param listeningElement
     * @returns a GenericResult struct
     */
    CoverageHandler.prototype.ListenNextNodeOnScreen = function (elementPath, listeningElement) {
        // Move to next element in path
        // Get it and it's repository
        var result = this.getNextPathRepository(elementPath);
        if (!result.success)
            return result;
        var elementRepositoryHandler = result.data.repositoryHandler;
        // Get the element coverage handler
        result = this.getElementCoverageHandler(elementRepositoryHandler, this, this.coverageHandlerByType.bind(this));
        if (!result.success)
            return result;
        var elementCoverageHandler = result.data.coverageHandler;
        // Deepening down using the element coverage handler
        return elementCoverageHandler.listenLastNodeOnScreen(elementPath, listeningElement);
    };
    /**
     * This method is Walking on element path and perform start listening on last element
     * @param elementPath path of element to listening to
     * @param attributes array of attribute to listen to
     * @returns a GenericResult struct
     */
    CoverageHandler.prototype.listenLastNodeOnScreen = function (elementPath, listeningElement) {
        // The ElementPath object contains our current position in the path.
        // If we reach the last one (the one needs actions on) go and start listening. Otherwise, go deeper.
        // We are the element needed to listen on.
        // Lets get the element.
        var result = this.getNodeOnScreen();
        var currentNode;
        if (result.success) {
            currentNode = result.data.accessResult;
        }
        //save current node on its coverage handler
        this.setNode(currentNode);
        if (elementPath.isLast()) {
            if (!this.executeStartListening(listeningElement)) {
                return this.returnFailure("Can't start listening for elementPath: " + elementPath);
            }
            return this.returnSuccess("");
        }
        else {
            // Go deeper on the path: Continue to next node
            return this.ListenNextNodeOnScreen(elementPath, listeningElement);
        }
    };
    /**
     * This method takes each attribute that was received to listen to, and registers to the changes on screen.
     * @param listeningElement the ListeningElement of this specific element
     * @returns default value is false
     */
    CoverageHandler.prototype.executeStartListening = function (listeningElement) {
        var _this = this;
        var _a, _b;
        this.listeningElement = listeningElement;
        this.listeningTriggersMap = new Map();
        //First, we initialize the map in order to have a unified list of the registration functions for triggers and attributes so that if we have the same attribute
        // in both attributes list and triggers list we will only call it once
        (_a = listeningElement.triggers) === null || _a === void 0 ? void 0 : _a.forEach(function (triggersData) {
            var triggerSubscriber = Array(triggersData.function);
            _this.listeningTriggersMap.set(triggersData.name, triggerSubscriber);
        });
        (_b = listeningElement.attributes) === null || _b === void 0 ? void 0 : _b.forEach(function (attributeData) {
            if (attributeData.changeEventSubscriber) {
                log.trace("AttributeData is: name " + attributeData.changeEventSubscriber.name + " and func is: " + attributeData.changeEventSubscriber.function);
                var registerFunction = _this.listeningTriggersMap.get(attributeData.changeEventSubscriber.name);
                if (!registerFunction) {
                    log.trace("attribute " + attributeData.changeEventSubscriber.name + " was not in the listeningTriggersMap, adding it");
                    var attributeSubscriber = Array(attributeData.changeEventSubscriber.function);
                    _this.listeningTriggersMap.set(attributeData.changeEventSubscriber.name, attributeSubscriber);
                }
                else {
                    //the name of the attribute already exists, need to check if the registrationFunction is the same
                    log.trace("attribute " + attributeData.changeEventSubscriber.name + " is in the listeningTriggersMap, checking if the function exists");
                    var foundFunction_1 = false;
                    registerFunction.forEach(function (func) {
                        if (func === attributeData.changeEventSubscriber.function)
                            foundFunction_1 = true;
                    });
                    if (!foundFunction_1) {
                        log.trace("function " + attributeData.changeEventSubscriber.function + " was not in the listeningTriggersMap, adding it");
                        _this.listeningTriggersMap[attributeData.changeEventSubscriber.name].push(attributeData.changeEventSubscriber.function);
                    }
                }
            }
        });
        return true;
    };
    /**
     * This method gets the actual node on the screen.
     * @returns a GenericResult with the node inside the data
     */
    CoverageHandler.prototype.getNodeOnScreen = function () {
        // If we can find ourself without relative to the previous result, great. If not,
        // ask our parent to get itself and we will be relative to it.
        if (this.canAccessDirectly()) {
            return this.getNode(null);
        }
        else {
            // We are relative to the parent
            if (this.parentCoverageHandler) {
                // Get the parent and get it relative to it.
                var result = this.parentCoverageHandler.getNodeOnScreen();
                if (!result.success) {
                    return result; // We failed to access parents path
                }
                var $parentNode = result.data.accessResult;
                return this.getNode($parentNode);
            }
            else {
                // No parent - we are relative to the body.
                return this.getNode(null);
            }
        }
    };
    /**
     * This method checks if we access directly to the node or access it with relativity to its parent.
     * @returns true if we can, false otherwise
     */
    CoverageHandler.prototype.canAccessDirectly = function () {
        // Return true if we can access the node without needing to reach the parent
        log.error("canAccessDirectly must be inherited");
        return false;
    };
    /**
     * This method checks if we can access the element directly by its fields, or we need to go up the parent.
     * @param repositoryHandler - the repositoryHandler to search in
     * @returns true if we can, false otherwise
     */
    CoverageHandler.prototype.canAccessDirectlyFromRepository = function (repositoryHandler) {
        // Return true if we can access the node without needing to reach the parent
        log.error("canAccessDirectlyFromRepository must be inherited");
        return false;
    };
    /**
     *  This method returns the actual node on screen
     * @param previousResult
     * @returns a GenericResult struct with data that holds the element that was found
     */
    CoverageHandler.prototype.getNode = function (previousResult) {
        return this.returnFailure("getNode needs to be inherited");
    };
    /**
     * This method sets the node for the control.
     * @param node - the node to set
     */
    CoverageHandler.prototype.setNode = function (node) {
        //Need to be inherited
    };
    /**
     * This method prepares the recorded step to be send to the platform: it merges the repository and reports the new tree,
     * it creates the snapshot of the element and reports the recorded step.
     * @param lAction - the action that was recorded
     */
    CoverageHandler.prototype.executeRecordedStep = function (lAction) {
        var _this = this;
        try {
            // This element need to be saved
            // We need to make sure we have the path and the repository to support it
            // and merge what we found now with the repository
            this.validateAndMergeRepository();
            // Report JBot about the changes in the repository
            this.reportTreeChanged();
        }
        catch (error) {
            this.platformDriver.throwException(error, "ReportTreeChangedException");
        }
        var elementCoordinates;
        try {
            log.debug("getElementCoordinates");
            elementCoordinates = this.getElementCoordinates();
            log.debug("got element coordinates");
            log.debug("createElementSnapshot");
            this.createElementSnapshot(function (snapshot) {
                log.debug("element snapshot created");
                try {
                    // Report JBot about the recording step
                    _this.reportRecordedStep(lAction, snapshot, elementCoordinates);
                }
                catch (error) {
                    _this.platformDriver.throwException(error, "ReportRecordedStepException");
                }
            });
        }
        catch (error) {
            log.error("cannot create element snapshot");
            try {
                // Report JBot about the recording step
                this.reportRecordedStep(lAction);
            }
            catch (error) {
                this.platformDriver.throwException(error, "ReportRecordedStepException");
            }
        }
    };
    /**
     * This method gets the elements' on screen coordinates.
     * @returns the screen coordinates of the element
     */
    CoverageHandler.prototype.getElementCoordinates = function () {
        log.error("Method getElementCoordinates must be inherited");
        return null;
    };
    /**
     * This method creates a snapshot for the element, after it was recorded or captured.
     * @param callback - the callback to be called when a snapshot is created.
     */
    CoverageHandler.prototype.createElementSnapshot = function (callback) {
        log.error("Method createElementSnapshot must be inherited");
        return null;
    };
    /**
     * This method prepares the captured element to be send to the platform: it merges the repository and reports the new tree,
     * it creates the snapshot of the element and reports the recorded step.
     * @param event
     * @returns
     */
    CoverageHandler.prototype.executeStartCapturingClicked = function (event) {
        var _this = this;
        log.debug("executeStartCapturingClicked");
        try {
            // This element need to be captured.
            // We need to make sure we have the path and the repository to support it
            // and merge what we found now with the repository
            this.validateAndMergeRepository();
            // Report JBot about the changes in the repository
            this.reportTreeChanged();
            var elementCoordinates_1;
            try {
                log.debug("getElementCoordinates");
                elementCoordinates_1 = this.getElementCoordinates();
                log.debug("got element coordinates");
                log.debug("createElementSnapshot");
                this.createElementSnapshot(function (snapshot) {
                    log.debug("element snapshot created");
                    try {
                        // Report JBot about the captured element
                        _this.reportCapturedElement(snapshot, elementCoordinates_1);
                    }
                    catch (error) {
                        log.error("Failed to report captured element");
                        _this.platformDriver.throwException(error, "ReportElementCapturedException");
                    }
                });
            }
            catch (error) {
                log.error("cannot create element snapshot");
                try {
                    // Report JBot about the captured element
                    this.reportCapturedElement();
                }
                catch (error) {
                    log.error("Failed to report captured element");
                    this.platformDriver.throwException(error, "ReportElementCapturedException");
                }
            }
        }
        catch (error) {
            this.platformDriver.throwException(error, "ReportTreeChangedException");
        }
        return false; // Stop other events
    };
    /**
     * This method creates a repository if it's not exist yet, and then merges the new one created with all the existing repository.
     */
    CoverageHandler.prototype.validateAndMergeRepository = function () {
        log.debug("validateAndMergeRepository");
        // We need to make sure we have the path and the repository to support it
        this.createRepositoryIfNotExists();
        // Merge what we found now with the repository
        var repositoryNode = this.createElementRepositoryNode();
        this.mergeRepositoryNode(repositoryNode);
    };
    /**
     * This method creates a new repository if is it doesn't exist.
     * @returns the new RepositoryHandler, or the existing one.
     */
    CoverageHandler.prototype.createRepositoryIfNotExists = function () {
        log.debug("createRepositoryIfNotExists");
        // Returns the current repository handler
        if (this.repositoryHandler) {
            log.debug("createRepositoryIfNotExists has a repositoryHandler");
            return this.repositoryHandler;
        }
        log.debug("createRepositoryIfNotExists doesn't have a repositoryHandler");
        // If we don't have yet, lets create it
        this.repositoryHandler = this.createRepositoryHandler();
        log.trace("createRepositoryIfNotExists: repository built is: " + JSON.stringify(this.repositoryHandler._repository.tree));
        return this.repositoryHandler;
    };
    /**
     * This method creates a repositoryHandler.
     * @returns the RepositoryHandler created.
     */
    CoverageHandler.prototype.createRepositoryHandler = function () {
        // As we eventually add our repository to the parent, let's validate that the parent has repository
        this.parentCoverageHandler.createRepositoryIfNotExists();
        // Now the parent has repositoryHandler.
        // We create our element and ask parent to add it and give us back the repository handler.
        var repositoryNode = this.createElementRepositoryNode();
        if (!repositoryNode) {
            log.debug("createRepositoryHandler: Empty repository node created");
            return null;
        }
        log.debug("createRepositoryHandler: repository node is: " + JSON.stringify(repositoryNode));
        // Update the repository tree itself. The tree object is common to all repositoryHandlers.
        repositoryNode = this.parentCoverageHandler.addChildRepositoryNodeToParent(repositoryNode);
        // Create a repository handler where we are the current node.
        return this.parentCoverageHandler.createChildRepositoryHandler(repositoryNode);
    };
    /**
     * This method Update the repository tree by adding the childRepositoryNode to the currentNodes' Children
     * @param childRepositoryNode
     * @returns the parent repository node if exists, or the repository node itself otherwise.
     */
    CoverageHandler.prototype.addChildRepositoryNodeToParent = function (childRepositoryNode) {
        log.debug("addChildRepositoryNodeToParent");
        // Update the repository tree by adding the childRepositoryNode to the currentNode Children
        var prevChildRepositoryNode = this.findSimilarElementInCurrent(childRepositoryNode);
        if (prevChildRepositoryNode) {
            log.debug("addChildRepositoryNodeToParent prevChildRepositoryNode exists");
            // A tricky part. Node already exists - Merge the nodes.
            this.mergeRepositoryNodes(prevChildRepositoryNode, childRepositoryNode);
            return prevChildRepositoryNode;
        }
        else {
            log.debug("addChildRepositoryNodeToParent prevChildRepositoryNode does NOT exist");
            // Just add to children
            this.repositoryHandler.addNodeToChildren(childRepositoryNode);
            return childRepositoryNode;
        }
    };
    /**
     * This method finds the element in the repository.
     * @param repositoryNode
     * @returns the repository node
     */
    CoverageHandler.prototype.findSimilarElementInCurrent = function (repositoryNode) {
        // By default we find by ID . However if it's auto generated id, look at the config
        var id = repositoryNode.id;
        log.debug("findSimilarElementInCurrent id: " + id);
        if (id && id.startsWith(Constants_1.Constants.AUTO_GENERATE_ID_PREFIX)) {
            log.debug("findSimilarElementInCurrent starts with " + Constants_1.Constants.AUTO_GENERATE_ID_PREFIX);
            return this.repositoryHandler.findElementByConfigInCurrent(repositoryNode.config);
        }
        else {
            log.debug("findSimilarElementInCurrent does NOT start with " + Constants_1.Constants.AUTO_GENERATE_ID_PREFIX);
            return this.repositoryHandler.findElementByIdInCurrent(id);
        }
    };
    /**
     * This method creates a repositoryHandler for the repositoryNode
     * @param childRepositoryNode
     * @returns the RepositoryHandler created
     */
    CoverageHandler.prototype.createChildRepositoryHandler = function (childRepositoryNode) {
        log.debug("createChildRepositoryHandler");
        // Create the new repository handler
        var childRepositoryHandler = new RepositoryHandler_1.default(this.repositoryHandler.repository, childRepositoryNode, this.repositoryHandler);
        return childRepositoryHandler;
    };
    /**
     * This method merges some elements in the repository but not all as arrays like children should be treated as add/update
     * @param repositoryNode - the node to merge
     */
    CoverageHandler.prototype.mergeRepositoryNode = function (repositoryNode) {
        // Merge some elements but not all as arrays like children should be treated as add/update
        // but not replace.
        if (!this.repositoryHandler.currentNode) {
            this.repositoryHandler.currentNode = repositoryNode;
            return;
        }
        this.mergeRepositoryNodes(this.repositoryHandler.currentNode, repositoryNode);
    };
    /**
     * This method loops on all nodes elements:
     * - Keep all the ones starting with "_" (manual)
     * - Update recursively all non-children elements
     * - Add/Override as is the children (if exists) as each one need to do it's own merge.
     * @param prevRepositoryNode - the previous repository node that needs to be merged
     * @param newRepositoryNode - the new repositoryNode after the merge
     */
    CoverageHandler.prototype.mergeRepositoryNodes = function (prevRepositoryNode, newRepositoryNode) {
        // Loop on all nodes elements:
        //    - Keep all the ones starting with "_" (manual)
        //    - Update recursively all non-children elements
        //    - Add/Override as is the children (if exists) as each one need to do it's own merge.
        this.removeUnusedRepositoryNodes(prevRepositoryNode, newRepositoryNode, true);
        this.addUpdateNewRepositoryNodes(prevRepositoryNode, newRepositoryNode, true);
    };
    /**
     * This method removes the unused repositoryNodes
     * @param prevRepositoryNode
     * @param newRepositoryNode
     * @param startOfNode - indicates if this is the starting node
     */
    CoverageHandler.prototype.removeUnusedRepositoryNodes = function (prevRepositoryNode, newRepositoryNode, startOfNode) {
        // Loop on existing items
        for (var key in prevRepositoryNode) {
            if (key.startsWith("_")) {
                // Indicates manual insert
                continue;
            }
            if (newRepositoryNode[key]) {
                // Exists in new.
                // Do the same for the object in case it's not 'children'.
                if (startOfNode && key === "children") {
                    continue;
                }
                var prevValue = prevRepositoryNode[key];
                if (prevValue instanceof Object) {
                    this.removeUnusedRepositoryNodes(prevValue, newRepositoryNode[key], false);
                }
                continue;
            }
            // Not in new, delete it
            log.debug("Deleting key " + key);
            delete prevRepositoryNode[key];
        }
    };
    /**
     * This method adds or updates to the prevRepositoryNodes
     * @param prevRepositoryNode - the repositoryNode to update
     * @param newRepositoryNode
     * @param startOfNode - indicates if this is the starting node
     */
    CoverageHandler.prototype.addUpdateNewRepositoryNodes = function (prevRepositoryNode, newRepositoryNode, startOfNode) {
        // Loop on new items
        for (var key in newRepositoryNode) {
            var newValue = newRepositoryNode[key];
            if (!prevRepositoryNode[key]) {
                // Doesn't Exists in new.
                prevRepositoryNode[key] = newValue; // Add it.
                continue;
            }
            // Exists in new. Needs merge.
            // Do not merge children
            if (startOfNode && key === "children") {
                continue;
            }
            // Do not override id  if they were auto generated as it will change the references to it
            if (startOfNode && key === "id") {
                continue;
            }
            // Do not override name if the name was auto generated from ID
            if (startOfNode && key === "name" && newValue.startsWith(Constants_1.Constants.AUTO_GENERATE_ID_PREFIX)) {
                continue;
            }
            if (newValue instanceof Object) {
                this.addUpdateNewRepositoryNodes(prevRepositoryNode[key], newValue, false);
            }
            else {
                prevRepositoryNode[key] = newValue;
            }
        }
    };
    /**
     * This method reports the recorded step back to the platform.
     * @param lAction - the action that was recorded
     * @param snapshot - the snapshot of the element recorded
     * @param coordinates - the coordinates of the element
     */
    CoverageHandler.prototype.reportRecordedStep = function (lAction, snapshot, coordinates) {
        log.debug("reportRecorderStep");
        this.platformDriver.reportRecordedStep(lAction, this.repositoryHandler.pathId, snapshot, coordinates);
    };
    /**
     * This method reports the repository tree changed back to the platform.
     * @param repositoryHandler - the changed repository
     */
    CoverageHandler.prototype.reportTreeChanged = function () {
        this.platformDriver.reportTreeChanged(this.repositoryHandler);
    };
    /**
     * This method reports the captured element to the platform
     * @param snapshot - the snapshot of the element captured
     * @param coordinates - the coordinates of the element
     * @returns true
     */
    CoverageHandler.prototype.reportCapturedElement = function (snapshot, coordinates) {
        return this.platformDriver.reportCapturedElement(this.repositoryHandler.pathId, snapshot, coordinates);
    };
    /**
     * This method reports the captured table to the platform
     * @param snapshot - the snapshot of the table captured
     * @param coordinates - the coordinates of the table
     */
    CoverageHandler.prototype.reportCapturedTable = function (fieldsPathIds, snapshot, coordinates) {
        this.platformDriver.reportCapturedTable(this.repositoryHandler.pathId, fieldsPathIds, snapshot, coordinates);
    };
    /**
     *  This method reports the changed element (while listening) to the platform.
     * @param pathId - the path to the element
     * @param attribute - the attribute that was changed
     * @param newValue - the new value of the attribute
     * @returns true
     */
    CoverageHandler.prototype.reportChangedElement = function (newValue, subscriberName) {
        var _a, _b;
        log.trace("In reportChangedElement");
        var foundAttribute = (_a = this.listeningElement.attributes) === null || _a === void 0 ? void 0 : _a.find(function (attributeData) { return attributeData != null && subscriberName.toLowerCase() === attributeData.changeEventSubscriber.name.toLowerCase(); });
        if (foundAttribute) {
            if (!this.platformDriver.reportChangedElement(this.repositoryHandler.pathId, foundAttribute.name, newValue)) {
                //TODO: Error handling
            }
        }
        if ((_b = this.listeningElement.triggers) === null || _b === void 0 ? void 0 : _b.some(function (triggerData) { return triggerData != null && subscriberName.toLowerCase() === triggerData.name.toLowerCase(); })) {
            if (!this.platformDriver.reportTriggerFired(this.repositoryHandler.pathId, subscriberName)) {
                //TODO: Error handling
            }
        }
        return true;
    };
    CoverageHandler.prototype.reportInitialValue = function (value, subscriberName) {
        var _a;
        log.trace("In reportInitialValue");
        var foundAttribute = (_a = this.listeningElement.attributes) === null || _a === void 0 ? void 0 : _a.find(function (attributeData) { return attributeData != null && subscriberName.toLowerCase() === attributeData.changeEventSubscriber.name.toLowerCase(); });
        if (foundAttribute) {
            if (!this.platformDriver.reportChangedElement(this.repositoryHandler.pathId, foundAttribute.name, value)) {
                //TODO: Error handling
            }
        }
    };
    /**
     * This method reports the trigger fired to the platform.
     * @param pathId - the path to the element
     * @param trigger - the trigger name that was fired
     * @returns true
     */
    CoverageHandler.prototype.reportTriggerFired = function (pathId, trigger) {
        log.debug("reportTriggerFired");
        return this.platformDriver.reportTriggerFired(pathId, trigger);
    };
    /**
     * This method indicates whether we need to add this node the repository or not.
     * @returns Default value is true.
     */
    CoverageHandler.prototype.isNodeToBeAddedToRepository = function () {
        return true;
    };
    /**
     * This method creates an empty element repository node.
     * @returns the repository node that was created
     */
    CoverageHandler.prototype.createBasicElementRepositoryNode = function () {
        var elementNode = {
            children: [],
            config: {},
        };
        return elementNode;
    };
    CoverageHandler.prototype.createElementRepositoryNode = function () { };
    return CoverageHandler;
}());
exports.default = CoverageHandler;
//# sourceMappingURL=CoverageHandler.js.map