import "../Model/RepositoryHandler";
import CoverageHandler from "./CoverageHandler";
import { GenericResult } from "../Model/GenericResult";
import ScreenCoverageHandler from "./ScreenCoverageHandler";
import RepositoryHandler from "../Model/RepositoryHandler";
import ExecutionLogicalAction from "../Model/ExecutionLogicalAction";
import ListeningInfo from "../Model/ListeningInfo";
import ListeningElement from "../Model/ListeningElement";
import PlatformDriver from "../PlatformDrivers/PlatformDriver";
import ApplicationData from "../Model/ApplicationData";
import CoverageHandlerFactory from "./CoverageHandlerFactory";
/**
 * The Coverage Handler in the application level. When initiated, it is given the platformDriver which is connected to the current coverageHandler
 *  of this application (such as the IE tab) and given the repository from this
 */
export default class ApplicationCoverageHandler extends CoverageHandler {
    constructor(platformDriver: PlatformDriver, repositoryHandler: RepositoryHandler, applicationData: ApplicationData, parentCoverageHandler: CoverageHandler, factory: CoverageHandlerFactory, applicationCoverageHandler?: ApplicationCoverageHandler);
    /**
     * Pointer to the current screen coverageHandler
     */
    currentScreenCoverageHandler: ScreenCoverageHandler;
    /**
     * Pointer to the list of elements to listen to
     */
    listeningElements: {};
    /**
    * This method executes the action received on the related element.
    * @param lElementPathId - the path to the element
    * @param lAction - a struct holding the action name and a list of values, when needed
    * @returns a GenericResult struct with the action result in the data
    */
    executeAction(lElementPathId: string, lAction: ExecutionLogicalAction): GenericResult;
    /**
    * This method executes asynchronously the action received on the related element.
    * @param lElementPathId - the path to the element
    * @param lAction - a struct holding the action name and a list of values, when needed
    * @returns a GenericResult struct with the action result in the data
    */
    executeActionAsync(lElementPathId: string, lAction: ExecutionLogicalAction): Promise<GenericResult>;
    /**
     * This method creates a default screenCoverageHandler, in case there isn't a specific one yet.
     * @param applicationCoverageHandler - the applicationCoverageHandler
     * @param screenRepositoryHandler - the applicationRepositoryHandler
     * @returns a new ScreenCoverageHandler
     */
    protected getDefaultScreenCoverageHandler(applicationCoverageHandler: CoverageHandler, screenRepositoryHandler: RepositoryHandler): ScreenCoverageHandler;
    /**
     * This method starts the recording process for all the application.
     * @returns a GenericResult struct
     */
    startRecording(): GenericResult;
    /**
     * This method stops the recording process for all the application.
     * @returns a GenericResult struct
     */
    stopRecording(): GenericResult;
    /**
     * This method starts the capturing process for all the application.
     * @returns a GenericResult
     */
    startCapturing(): GenericResult;
    /**
     * This method gets the screen coverageHandler for the current screen.
     * @returns a GenericResult with the screen coverageHandler inside the data
     */
    protected getScreenCoverageHandlerForCurrent(): GenericResult;
    /**
     * This method gets the default screen coverageHandler for the current screen.
     * @returns a new ScreenCoverageHandler
     */
    getDefaultScreenCoverageHandlerForCurrent(): ScreenCoverageHandler;
    /**
     * This method gets the repository for the application - application level should always have repository, even if empty
     * @returns the RepositoryHandler
     */
    createRepositoryIfNotExists(): RepositoryHandler;
    /**
     * This method creates a default screen coverageHandler.
     * @returns a new ScreenCoverageHandler
     */
    protected createDefaultScreenCoverageHandler(): ScreenCoverageHandler;
    /**
     * This method stops the capturing process for all the application.
     * @returns a GenericResult struct
     */
    stopCapturing(): GenericResult;
    /**
     * This method starts the listening process.
     * @returns a GenericResult struct
     */
    startListening(): GenericResult;
    /**
     * This method starts listening on each element from ListeningElements
     * @param listeningElement the listeningElement to listen to
     */
    protected startListeningOnElement(listeningElement: ListeningElement): void;
    /**
     * This method sets the listeningElements list.
     * @param listeningInfos
     */
    setListeningInfo(listeningInfos: ListeningInfo[]): void;
    /**
     * This method adds the listeningInfos received to the listeningElements.
     * @param listeningInfos
     */
    private addListeningInfos;
    /**
     * This method adds a single listeningInfo to the listeningElements.
     */
    protected addListeningInfo(listeningInfo: ListeningInfo): ListeningElement;
    /**
     * This method gets a listeningElement, given the pathId.
     * @param path - the path to search
     * @returns the appropriate ListeningElement
     */
    getListeningElement(path: string): ListeningElement;
    /**
     * This method stops the listening process for all the application.
     * @returns a GenericResult struct
     */
    stopListening(): GenericResult;
    /**
     * Get current screen and notify it that a page was opened
     */
    pageOpened(): void;
}
