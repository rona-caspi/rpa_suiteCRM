import CoverageHandlerFactory from "./CoverageHandlerFactory";
import { GenericResult } from "../Model/GenericResult";
import RepositoryHandler from "../Model/RepositoryHandler";
import PlatformDriver from "../PlatformDrivers/PlatformDriver";
import ElementData from "../Model/ElementData";
import LogicalAction from "../Model/LogicalAction";
import ElementPath from "../Model/ElementPath";
import ApplicationData from "../Model/ApplicationData";
import ListeningElement from "../Model/ListeningElement";
import ApplicationCoverageHandler from "./ApplicationCoverageHandler";
import ExecutionLogicalAction from "../Model/ExecutionLogicalAction";
export default class CoverageHandler {
    /**
     *  Provide API to JBot amd the platform
     *  */
    platformDriver: PlatformDriver;
    /**
     * Holds the repository handler which has a copy of the repository while the current node in the RH points to our node in the repository.
     */
    repositoryHandler: RepositoryHandler;
    /**
     * Our global data mechanism for this coverage.
     */
    applicationData: ApplicationData;
    /**
     * Pointer to our parent in case of hierarchy or null if no parent (application or screen level depends on the Coverage implementation)
     */
    parentCoverageHandler: CoverageHandler;
    /**
     * Pointer to a list of the controls' children
     */
    childrenCoverageHandler: CoverageHandler[];
    /**
     * Pointer to the application coverage handler
     */
    applicationCoverageHandler: ApplicationCoverageHandler;
    protected listeningTriggersMap: Map<string, string[]>;
    protected listeningElement: ListeningElement;
    /**Coverage handler factory to instantiate coverages by node and type  */
    factory: CoverageHandlerFactory;
    constructor(platformDriver: PlatformDriver, repositoryHandler: RepositoryHandler, applicationData: ApplicationData, parentCoverageHandler: CoverageHandler, factory: CoverageHandlerFactory, applicationCoverageHandler?: ApplicationCoverageHandler);
    /**
     * This method executes the action received on the related element.
     * @param lElementPathId - the path to the element
     * @param lAction - a struct holding the action name and a list of values, when needed
     * @returns a GenericResult struct with the action result in the data
     */
    executeAction(lElementPathId: string, lAction: ExecutionLogicalAction): GenericResult;
    /**
     * This method executes the action received on the related element.
     * @param lElementPathId - the path to the element
     * @param lAction - a struct holding the action name and a list of values, when needed
     * @returns a GenericResult struct with the action result in the data
     */
    executeActionAsync(lElementPathId: string, lAction: ExecutionLogicalAction): Promise<GenericResult>;
    /**
     * This method starts the recording process.
     * @returns a GenericResult struct
     */
    startRecording(): GenericResult;
    /**
     * This method stops the recording process.
     * @returns a GenericResult struct
     */
    stopRecording(): GenericResult;
    /**
     * This method starts the capturing process.
     * @returns a GenericResult
     */
    startCapturing(): GenericResult;
    /**
     * This method stops the capturing process.
     * @returns a GenericResult struct
     */
    stopCapturing(): GenericResult;
    /**
     * This method starts the listening process.
     * @returns a GenericResult struct
     */
    startListening(): GenericResult;
    /**
     * This method stops the listening process.
     * @returns a GenericResult struct
     */
    stopListening(): GenericResult;
    /**
     * This method iterates on the parentNodes' children and on each child it performs the func function.
     * @param parentNode - the node to iterate its children on.
     * @param func - the function that will be execute on each child
     */
    walkOnChildren(parentNode: any, func: any): void;
    /**
     * This method registers the element for highlighting (for recording and capturing process), it sets it in the highlightMap.
     * @param controlCoverageHandler - the elements' coverageHandler
     * @param elem - the node
     * @param functionHandler - the callback function to call in case we are in capturing mode.
     */
    registerControlForHighlight(controlCoverageHandler: CoverageHandler, elem: any, functionHandler: Function): void;
    /**
     * This method sets a GenericResult struct with failure value, and an error message.
     * @param errorMessage
     * @returns a GenericResult struct with failure value.
     */
    protected returnFailure(errorMessage: string): GenericResult;
    /**
     * This method sets a GenericResult struct with success value, and data.
     * @param data
     * @returns  a GenericResult struct with success value.
     */
    protected returnSuccess(data?: any): GenericResult;
    /**
     * This method creates a coverageHandler for the element, using the defaultCoverageHandlerFunction in case it doesn't exist yet, or return it
     * if it is already exist.
     * @param repositoryHandler - the repositoryHandler holds the path to the element
     * @param parentCoverageHandler
     * @param defaultCoverageHandlerFunction - the default function to create a coverageHandler
     * @returns a GenericResult struct with the coverageHandler inside the data.
     */
    protected getElementCoverageHandler(repositoryHandler: RepositoryHandler, parentCoverageHandler: CoverageHandler, defaultCoverageHandlerFunction: Function): GenericResult;
    /**
     * TODO RONA : change name?
     * This method returns a struct holding coverageHandler for the element, that was stored in applicationData field.
     * In case there still isn't a stored coverageHandler, it creates an empty struct.
     * @param pathId - the path of the element
     * @returns a ElementData struct that holds the coverageHandler.
     */
    protected pathIdToTemporaryElementData(pathId: string): ElementData;
    /**
     * This method stores the coverageHandler in applicationData field using the uniqueId as the key.
     * @param uniqueId
     */
    saveCoverageHandlerForUniqueId(uniqueId: string): void;
    /**
     * This method deletes the coverageHandler stored in applicationData field using the uniqueId as the key.
     * @param uniqueId
     */
    protected deleteCoverageHandlerForUniqueId(uniqueId: string): void;
    /**
     * This method gets the coverageHandler stored in applicationData field by the uniqueId.
     * @param uniqueId
     * @returns the coverageHandler
     */
    fetchCoverageHandlerFromUniqueId(uniqueId: string): CoverageHandler;
    /**
     * This method deletes all the data stored in the applicationData field.
     */
    protected deleteAllElementDataTopic(): void;
    /**
     * This method gets a control type and returns the suitable coverageHandler.
     * @param controlType
     * @returns a GenericResult struct with the coverageHandler inside the data
     */
    protected getCoverageHandlerByNode(node: any): GenericResult;
    /**
     * This method gets the repository for an element that is the next on the path.
     * @param elementPath
     * @returns a GenericResult struct with the repositoryHandler inside the data
     */
    protected getNextPathRepository(elementPath: ElementPath): GenericResult;
    /**
     * This method gets the repository for an element that is the next on the path, and creates a coverageHandler
     * @param elementPath
     * @returns a GenericResult struct with the coverageHandler inside the data
     */
    protected getCoverageHandlerByNextPath(elementPath: ElementPath): GenericResult;
    /**
     * This method gets the element that is next on the pathId.
     * @param elementPath
     * @returns a GenericResult struct with the element inside the data
     */
    private getNextPathElement;
    /**
     * This method finds an element by its Id in the repository.
     * @param lElementId
     * @returns the element found, or null.
     */
    findElementByIdInCurrent(lElementId: string): any;
    /**
     * This method creates a repositoryHandler for the given element and pathId.
     * @param nodeElement
     * @param pathId
     * @returns the created repositoryHandler.
     */
    private createRepositoryForNode;
    /**
     * This method gets a coverageHandler by its type.
     * @param me
     * @param repositoryHandler
     * @returns the coverageHandler.
     */
    protected coverageHandlerByType(me: CoverageHandler, repositoryHandler: RepositoryHandler): CoverageHandler;
    /**
     * This method gets a coverageHandler by its type in the repository.
     * @param repositoryHandler
     * @param me
     * @param controlType
     * @returns the coverageHandler.
     */
    private getCoverageHandlerByTypeInRepository;
    /**
     * This method creates the element coverageHandler according to the elementPath
     * @param elementPath - the repository path of the element
     * @returns a GenericResult with the coverageHandler created inside the data
     */
    protected getCoverageHandlerByNextPathInRepository(elementPath: ElementPath): GenericResult;
    /**
     * This method is digging down all the way to the requested element on the elementPath for listening.
     * @param elementPath
     * @param listeningElement
     * @returns a GenericResult struct
     */
    private ListenNextNodeOnScreen;
    /**
     * This method is Walking on element path and perform start listening on last element
     * @param elementPath path of element to listening to
     * @param attributes array of attribute to listen to
     * @returns a GenericResult struct
     */
    listenLastNodeOnScreen(elementPath: ElementPath, listeningElement: ListeningElement): GenericResult;
    /**
     * This method takes each attribute that was received to listen to, and registers to the changes on screen.
     * @param listeningElement the ListeningElement of this specific element
     * @returns default value is false
     */
    executeStartListening(listeningElement: ListeningElement): boolean;
    /**
     * This method gets the actual node on the screen.
     * @returns a GenericResult with the node inside the data
     */
    getNodeOnScreen(): GenericResult;
    /**
     * This method checks if we access directly to the node or access it with relativity to its parent.
     * @returns true if we can, false otherwise
     */
    canAccessDirectly(): boolean;
    /**
     * This method checks if we can access the element directly by its fields, or we need to go up the parent.
     * @param repositoryHandler - the repositoryHandler to search in
     * @returns true if we can, false otherwise
     */
    protected canAccessDirectlyFromRepository(repositoryHandler: RepositoryHandler): boolean;
    /**
     *  This method returns the actual node on screen
     * @param previousResult
     * @returns a GenericResult struct with data that holds the element that was found
     */
    getNode(previousResult?: any): GenericResult;
    /**
     * This method sets the node for the control.
     * @param node - the node to set
     */
    setNode(node: any): void;
    /**
     * This method prepares the recorded step to be send to the platform: it merges the repository and reports the new tree,
     * it creates the snapshot of the element and reports the recorded step.
     * @param lAction - the action that was recorded
     */
    executeRecordedStep(lAction: LogicalAction): void;
    /**
     * This method gets the elements' on screen coordinates.
     * @returns the screen coordinates of the element
     */
    protected getElementCoordinates(): number[];
    /**
     * This method creates a snapshot for the element, after it was recorded or captured.
     * @param callback - the callback to be called when a snapshot is created.
     */
    protected createElementSnapshot(callback?: (snapshot: string) => void): void;
    /**
     * This method prepares the captured element to be send to the platform: it merges the repository and reports the new tree,
     * it creates the snapshot of the element and reports the recorded step.
     * @param event
     * @returns
     */
    protected executeStartCapturingClicked(event: any): boolean;
    /**
     * This method creates a repository if it's not exist yet, and then merges the new one created with all the existing repository.
     */
    protected validateAndMergeRepository(): void;
    /**
     * This method creates a new repository if is it doesn't exist.
     * @returns the new RepositoryHandler, or the existing one.
     */
    createRepositoryIfNotExists(): RepositoryHandler;
    /**
     * This method creates a repositoryHandler.
     * @returns the RepositoryHandler created.
     */
    createRepositoryHandler(): RepositoryHandler;
    /**
     * This method Update the repository tree by adding the childRepositoryNode to the currentNodes' Children
     * @param childRepositoryNode
     * @returns the parent repository node if exists, or the repository node itself otherwise.
     */
    addChildRepositoryNodeToParent(childRepositoryNode: any): any;
    /**
     * This method finds the element in the repository.
     * @param repositoryNode
     * @returns the repository node
     */
    findSimilarElementInCurrent(repositoryNode: any): any;
    /**
     * This method creates a repositoryHandler for the repositoryNode
     * @param childRepositoryNode
     * @returns the RepositoryHandler created
     */
    createChildRepositoryHandler(childRepositoryNode: any): RepositoryHandler;
    /**
     * This method merges some elements in the repository but not all as arrays like children should be treated as add/update
     * @param repositoryNode - the node to merge
     */
    private mergeRepositoryNode;
    /**
     * This method loops on all nodes elements:
     * - Keep all the ones starting with "_" (manual)
     * - Update recursively all non-children elements
     * - Add/Override as is the children (if exists) as each one need to do it's own merge.
     * @param prevRepositoryNode - the previous repository node that needs to be merged
     * @param newRepositoryNode - the new repositoryNode after the merge
     */
    private mergeRepositoryNodes;
    /**
     * This method removes the unused repositoryNodes
     * @param prevRepositoryNode
     * @param newRepositoryNode
     * @param startOfNode - indicates if this is the starting node
     */
    private removeUnusedRepositoryNodes;
    /**
     * This method adds or updates to the prevRepositoryNodes
     * @param prevRepositoryNode - the repositoryNode to update
     * @param newRepositoryNode
     * @param startOfNode - indicates if this is the starting node
     */
    private addUpdateNewRepositoryNodes;
    /**
     * This method reports the recorded step back to the platform.
     * @param lAction - the action that was recorded
     * @param snapshot - the snapshot of the element recorded
     * @param coordinates - the coordinates of the element
     */
    protected reportRecordedStep(lAction: LogicalAction, snapshot?: string, coordinates?: number[]): void;
    /**
     * This method reports the repository tree changed back to the platform.
     * @param repositoryHandler - the changed repository
     */
    protected reportTreeChanged(): void;
    /**
     * This method reports the captured element to the platform
     * @param snapshot - the snapshot of the element captured
     * @param coordinates - the coordinates of the element
     * @returns true
     */
    protected reportCapturedElement(snapshot?: string, coordinates?: number[]): boolean;
    /**
     * This method reports the captured table to the platform
     * @param snapshot - the snapshot of the table captured
     * @param coordinates - the coordinates of the table
     */
    reportCapturedTable(fieldsPathIds: string[], snapshot?: string, coordinates?: number[]): void;
    /**
     *  This method reports the changed element (while listening) to the platform.
     * @param pathId - the path to the element
     * @param attribute - the attribute that was changed
     * @param newValue - the new value of the attribute
     * @returns true
     */
    reportChangedElement(newValue: unknown, subscriberName: string): boolean;
    reportInitialValue(value: unknown, subscriberName: string): void;
    /**
     * This method reports the trigger fired to the platform.
     * @param pathId - the path to the element
     * @param trigger - the trigger name that was fired
     * @returns true
     */
    reportTriggerFired(pathId: string, trigger: string): boolean;
    /**
     * This method indicates whether we need to add this node the repository or not.
     * @returns Default value is true.
     */
    isNodeToBeAddedToRepository(): boolean;
    /**
     * This method creates an empty element repository node.
     * @returns the repository node that was created
     */
    protected createBasicElementRepositoryNode(): any;
    protected createElementRepositoryNode(): any;
}
