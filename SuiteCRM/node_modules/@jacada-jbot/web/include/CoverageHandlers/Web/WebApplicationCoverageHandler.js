"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ApplicationCoverageHandler_1 = require("@jacada-jbot/base/include/CoverageHandlers/ApplicationCoverageHandler");
const WebScreenCoverageHandler_1 = require("./WebScreenCoverageHandler");
const ElementPath_1 = require("@jacada-jbot/base/include/Model/ElementPath");
const Log4jConfig_1 = require("@jacada-jbot/base/include/Utils/Log4jConfig");
const log = Log4jConfig_1.logFactory.getLogger("WebApplicationCoverageHandler");
/**
 * Coverage handler for a application
 */
class WebApplicationCoverageHandler extends ApplicationCoverageHandler_1.default {
    getDefaultScreenCoverageHandler(applicationCoverageHandler, screenRepositoryHandler) {
        return new WebScreenCoverageHandler_1.default(applicationCoverageHandler.platformDriver, screenRepositoryHandler, applicationCoverageHandler.applicationData, applicationCoverageHandler, applicationCoverageHandler.factory, this);
    }
    startListening() {
        this.startListeningOnScreen();
        super.startListening();
        return this.returnSuccess("");
    }
    /**
     * Starts listening on iFrames
     */
    startListeningOnFrame() {
        this.startListeningOnScreen();
    }
    /**
     * Start listening on specific element in iFrame
     * @param listeningInfo
     */
    startListeningOnFrameElement(listeningInfo) {
        let listeningElement = this.addListeningInfo(listeningInfo);
        this.startListeningOnElement(listeningElement);
    }
    startListeningOnScreen() {
        let result = this.getScreenCoverageHandlerForCurrent();
        if (!result.success)
            return;
        this.currentScreenCoverageHandler = result.data.coverageHandler;
        this.currentScreenCoverageHandler.startListening();
    }
    stopListening() {
        log.info('Stopping listening process');
        //Stops a listening process
        if (this.currentScreenCoverageHandler) {
            return this.currentScreenCoverageHandler.stopListening();
        }
        ;
        return this.returnSuccess("Stopped listening on application level only");
    }
    stopRecording() {
        log.info('Stopping recording process');
        // Stops a recording process
        if (this.currentScreenCoverageHandler)
            return this.currentScreenCoverageHandler.stopRecording();
        return this.returnSuccess("Stopped recording on application level only");
    }
    stopCapturing() {
        log.info('Stopping capturing process');
        // Stops a capturing process
        if (this.currentScreenCoverageHandler)
            return this.currentScreenCoverageHandler.stopCapturing();
        return this.returnSuccess("Stopped capturing on application level only");
    }
    /**
     * This method validates the element path - before execution
     * @param lElementPathId - the element path id
     * @param lAction - the action to execute
     * @returns a GenericResult
     */
    async validateElementPath(lElementPathId, lAction) {
        let elementPath = new ElementPath_1.default(lElementPathId);
        // TBD: Incase application doesn't exist, execute the lifecycle
        // The first element is 'us' (the application). 
        let applicationId = elementPath.next();
        if (applicationId === null)
            return this.returnFailure("Empty element path id");
        log.debug(`validateElementPath: applicationId is: ${applicationId}`);
        // If we are last, the application exists
        if (elementPath.isLast()) {
            return this.returnSuccess("Application exists");
        }
        else {
            // Second element is the screen. Get it and its repository
            let result = this.getNextPathRepository(elementPath);
            if (!result.success)
                return result;
            let screenRepositoryHandler = result.data.repositoryHandler;
            log.debug(`validateElementPath: screen repository handler id is ${screenRepositoryHandler.id} and path is ${screenRepositoryHandler.pathId}`);
            // get the screen coverage handler
            result = this.getElementCoverageHandler(screenRepositoryHandler, this, this.getDefaultScreenCoverageHandler.bind(this));
            if (!result.success)
                return result;
            let screenCoverageHandler = result.data.coverageHandler;
            // Check if screen and control exists
            return screenCoverageHandler.validateScreenAndControls(elementPath, lAction);
        }
    }
}
exports.default = WebApplicationCoverageHandler;
//# sourceMappingURL=WebApplicationCoverageHandler.js.map