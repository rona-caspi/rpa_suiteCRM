import ControlCoverageHandler from "@jacada-jbot/base/include/CoverageHandlers/ControlCoverageHandler";
import { GenericResult } from "@jacada-jbot/base/include/Model/GenericResult";
import CoverageHandler from "@jacada-jbot/base/include/CoverageHandlers/CoverageHandler";
import LabelWebControlCoverageHandler from "./LabelWebControlCoverageHandler";
import RepositoryHandler from "@jacada-jbot/base/include/Model/RepositoryHandler";
import ListeningElement from "@jacada-jbot/base/include/Model/ListeningElement";
import LogicalAction from "@jacada-jbot/base/include/Model/LogicalAction";
import { BaseCustomControlCoverageHandler } from "@jacada-jbot/base/include/CoverageHandlers/BaseCustomControlCoverageHandler";
export default class WebControlCoverageHandler extends ControlCoverageHandler {
    /**
     * A name of value attribute (e.g. text for text input)
     *  */
    protected readonly attributeValueName: string;
    /**
     * JQuery element for this instance
     */
    $currentNode: JQuery;
    _domNode: HTMLElement;
    /**
     * In Web, another Label element can point to this element and set its label
     */
    labelCoverageHandler?: LabelWebControlCoverageHandler;
    customCoverageHandler: BaseCustomControlCoverageHandler;
    set domNode(node: HTMLElement);
    get domNode(): HTMLElement;
    protected executeAccessNodeWithSelector($previousResult: any): GenericResult;
    canAccessDirectly(): boolean;
    protected canAccessDirectlyFromRepository(repositoryHandler: RepositoryHandler): boolean;
    createRepositoryHandler(): RepositoryHandler;
    /**
     * Check if RepositoryHandler has a valid configuration field
     * @returns true if it has and it is not empty otherwise false
     */
    private validateRepositoryConfiguration;
    /**
     * This method gets the selector part from the field section in the repository
     * @returns selector if a selector exists otherwise false
     */
    private getSelectorFromRepository;
    /**
     * This method sets the basic and common fields in the repository for each control
     * @returns
     */
    protected createBasicElementRepositoryNode(): any;
    createElementRepositoryNode(): any;
    /**
     * This method converts repository node fields into standard fields that acceptable for RPA
     * @param repositoryNode a repository node after it modified by coverage writer
     */
    protected standardizeRepositoryNodeFields(repositoryNode: any): void;
    /**
     * Create selector recursively, if parent of elementDomNode has an id use it
     * otherwise go to elementDomNode parent until body element
     * @remark This function might use name attribute of elementDomNode as unique id.
     * If your app contains multiple elements with same name attribute you should override this function
     * @param elementDomNode current DOM node
     * @returns
     */
    protected createRepositoryNodeSelector(elementDomNode: HTMLElement): string;
    /**
     * Create selector for a child
     * @param childDomNode A child we would like to create a selector
     * @param useExistingSelector If true take existing selector from repository handler otherwise go to parent
     * @returns
     */
    createSelectorToChild(childDomNode: HTMLElement, useExistingSelector: boolean): string;
    /**
     * Create an anchor selector for control coverage that not override createSelectorToChild function
     * @param useExistingSelector if true use selector
     * @returns
     */
    protected createAnchorSelector(useExistingSelector: boolean): string;
    protected concatenateSelectorParts(anchorSelector: string, partialSelector: string): string;
    /**
     * This method creates a selector command that finds the element node on parent element.
     * By default we do it by finding the element type and it's index. So, lets walk
     * @param parentDomNode parent of current DOM element
     * @param elementDomNode current DOM element
     * @returns the created selector
     */
    createSelectorFromParentToChild(parentDomNode: HTMLElement, elementDomNode: HTMLElement): string;
    /**
     * Get a name for this control
     * @param $domNode
     * @param repositoryNode
     * @returns the name
     */
    protected getName(repositoryNode: any): string;
    /**
     * Get name from a label current DOM node
     * @param $domNode current DOM node
     * @param repositoryNode
     * @returns the name
     */
    getNameFromLabel(): string;
    /**
     * Get name of parent DOM node
     * @param $domNode
     * @returns the name
     */
    protected getNameFromParent(): string;
    protected getParentNode(): JQuery;
    /**
     * This method returns a default value for the element in case we didn't find any name
     * @remark This function should be override
     * @returns
     */
    protected nodeNoName(): string;
    /**
     * Add a $ sign as a prefix to selector
     * @param selector
     * @returns The selector with $ sign
     */
    private createJQuerySelectorCommand;
    /**
     * Try to start listening on this coverage handler
     * @returns True if this coverage start listening successfully or coverage is not listenable, Otherwise false
     */
    private performControlStartListening;
    /**
     * This function register controlCoverageHandler on highlight, meaning that only registered element will be highlighted
     * during capturing and once they been clicked the functionHandler will be invoked
     * @param controlCoverageHandler that will be register for highlight
     * @param $elem jquery DOM node object
     * @param functionHandler event handler
     */
    registerControlForHighlight(controlCoverageHandler: WebControlCoverageHandler, $elem: JQuery, functionHandler: Function): void;
    /**
     * Get the text contents of element DOM node
     * @param $elem
     * @returns
     */
    protected ownText($elem: JQuery): string;
    protected getElementCoordinates(): number[];
    /**
     * Highlight element DOM node with red color before snapshot
     * @param $elem DOM node
     * @param show
     */
    private highlightBeforeSnapshot;
    /**
     * This method prepares the recorded step to be send to the platform: it merges the repository and reports the new tree,
     * it creates the snapshot of the element and reports the recorded step.
     * @param lAction - the action that was recorded
     */
    executeRecordedStep(lAction: LogicalAction): Promise<void>;
    protected createElementSnapshot(callback?: (snapshot: string) => void): Promise<void>;
    getNode($previousResult: any): GenericResult;
    setNode(node: HTMLElement): void;
    executeStartListening(listeningElement: ListeningElement): boolean;
    performStartRecording(): GenericResult;
    /**
     * This method starts the recording process on new element that were added to the screen by the
     * mutation observer.
     * @param nodesStack - an array of the new HTMLElement to start recording on
     * @returns a GenericResult struct
     */
    performStartRecordingOnNodesStack(nodesStack: HTMLElement[]): GenericResult;
    /**
     *  This method starts the listening process on new element that were added to the screen by the
     * mutation observer.
     * @param nodesStack - an array of the new HTMLElement to start recording on
     * @returns a GenericResult struct
     */
    performStartListeningOnNodesStack(nodesStack: HTMLElement[]): GenericResult;
    /**
     * This method starts the process of capturing for this element and, in case the performCapturingOnChildren is true,
     * it also iterate on its children to start capturing on them also.
     * @returns
     */
    performStartCapturing(): GenericResult;
    walkOnChildren(parentNode: HTMLElement, func: any, includeTextNodes?: boolean): void;
    /**
     * This method checks if the TEXT_NODE element has ELEMENT_NODE siblings
     * @param parentNode
     * @returns true if it as ELEMENT_NODE siblings, false otherwise
     */
    private checkForElementNodeSiblings;
    performStartRecordingOnNode(node: HTMLElement): boolean;
    /**
     * Search and retrieve from memory a coverage handler which was set for this node.
     * @param node - the node we looking to find coverage for. The coverage returned can be from any coverage handler class.
     */
    private fetchCoverageHandlerFromNode;
    /**
     * This method gets a node and returns it's coverageHandler.
     * @param node - the node to get it's coverage handler
     * @returns the suitable coverageHandler.
     */
    protected getCoverageHandlerForNode(node: HTMLElement): CoverageHandler;
    protected getCoverageHandler(node: HTMLElement): WebControlCoverageHandler;
    /**
     * This method gets a HTMLElement and HTMLElement array and starts the recording process on the
     * nodes in the array.
     * @param node -
     * @param nodesStack
     * @returns true
     */
    protected performStartRecordingOnNodeAndStack(node: HTMLElement, nodesStack: HTMLElement[]): boolean;
    /**
     * This method gets a HTMLElement and HTMLElement array and starts the listening process on the
     * nodes in the array.
     * @param node
     * @param nodesStack
     * @returns
     */
    protected performStartListeningOnNodeAndStack(node: HTMLElement, nodesStack: HTMLElement[]): boolean;
    performStartCapturingOnNode(node: HTMLElement): boolean;
    protected cleanId(name: string): string;
    protected cleanName(name: string): string;
    /**
     * Each coverage handler has label coverage handler property
     * This function assign it to current coverage handler
     */
    protected fetchLabelIfExists(): void;
    /**
     * collect all coverage handler fields and store their path into fieldsPathIds
     * @param fieldsPathIds array of fields path id
     */
    collectFieldsPathIds(fieldsPathIds: string[]): void;
    /**
     * This method checks if the node has children that are not text nodes, in order to determine if it's a leaf.
     * @returns true, if it has children other than text nodes, false otherwise
     */
    private nodeHasChildrenElements;
    /**
     * TODO:Add description
     * @param node DOM node
     * @param fieldsPathIds
     * @returns
     */
    collectFieldsPathIdsOnNode(node: HTMLElement, fieldsPathIds: string[]): boolean;
    /**
     * This method reports that element's attribute has changed to the platform
     * @param listeningElement
     * @param attribute
     * @param value
     */
    protected reportAttributeChanged(listeningElement: ListeningElement, attribute: string, value: any): void;
}
