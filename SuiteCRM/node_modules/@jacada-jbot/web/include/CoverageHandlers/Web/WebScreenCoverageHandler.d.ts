import CoverageHandler from "@jacada-jbot/base/include/CoverageHandlers/CoverageHandler";
import ScreenCoverageHandler from "@jacada-jbot/base/include/CoverageHandlers/ScreenCoverageHandler";
import { GenericResult } from "@jacada-jbot/base/include/Model/GenericResult";
import ApplicationCoverageHandler from "@jacada-jbot/base/include/CoverageHandlers/ApplicationCoverageHandler";
import PlatformDriver from "@jacada-jbot/base/include/PlatformDrivers/PlatformDriver";
import RepositoryHandler from "@jacada-jbot/base/include/Model/RepositoryHandler";
import ApplicationData from "@jacada-jbot/base/include/Model/ApplicationData";
import WebControlCoverageHandler from "./WebControlCoverageHandler";
import WebHighlight from "../../Utils/WebHighlight";
import WebHighlightElementData from "../../Model/WebHighlightElementData";
import WebAppSectionCoverageHandler from "./WebAppSectionCoverageHandler";
import ElementPath from "@jacada-jbot/base/include/Model/ElementPath";
import ExecutionLogicalAction from "@jacada-jbot/base/include/Model/ExecutionLogicalAction";
import ListeningElement from "@jacada-jbot/base/include/Model/ListeningElement";
import CoverageHandlerFactory from "@jacada-jbot/base/include/CoverageHandlers/CoverageHandlerFactory";
/**
 * Coverage handler for screen
 */
export default class WebScreenCoverageHandler extends ScreenCoverageHandler {
    /**
     * Mapping of controls to capture element data. Only controls which are here will be highlighted
     */
    highlightMap: {
        [nodeUniqueId: string]: WebHighlightElementData;
    };
    /**
     * True in case we have started capturing
     *  */
    inCaptureMode: boolean;
    /**
     * The DIV above the control which shows the highlight
     */
    highlightObject: WebHighlight;
    snapshotHighlightObject: WebHighlight;
    /**
     * Handles web modifications
     */
    mutationObserver: MutationObserver;
    /**
     * Array of app sections on the screen. Can be empty
     */
    appSections: WebAppSectionCoverageHandler[];
    /**
     * The last unique id of this coverage. If it has changed, we are in a new screen
     */
    lastUniqueId: String;
    /**
     * Postpone mutation observer callback execution until after wait milliseconds have elapsed since the last time it was invoked.
     */
    protected waitTimeBeforeDetactChanges: number;
    protected type(): string;
    constructor(platformDriver: PlatformDriver, repositoryHandler: RepositoryHandler, applicationData: ApplicationData, parentCoverageHandler: CoverageHandler, factory: CoverageHandlerFactory, applicationCoverageHandler: ApplicationCoverageHandler);
    screenChanged(): void;
    /**
     * Loading the app sections of this screen
     */
    private loadAppSection;
    /**
     * Creates the app sections of this screen. Coverage handler with app sections need to inherit this method and create the app sections
     */
    private createAppSections;
    /**
     * The path might be to the app section, not just to this screen so groupNavbar or header is valid.
     * If we have app sections, lets handle them
     * @returns
     */
    validateScreen(): GenericResult;
    /**
     *  On a default web screen, which is HTML based, each element decides what to record.
     *  Here we walk on the dom and each element we decide if to listen to it, and listen to it's children.
     * @returns
     */
    startRecording(): GenericResult;
    stopRecording(): GenericResult;
    private stopRecordingOnFrames;
    /**
     *  Remove all elements with Registered Attr.
     */
    private removeAllRegisteredEvents;
    /**
     *  Remove element with Registered Attr.
     */
    private removeRegisteredEvent;
    /**
     * Remove all registered coverage handlers by JBOT_COVERAGE_HANDLER_UNIQUE_ID_ATTR attribute
     */
    private removeAllCoverageHandlersFromNode;
    performStartRecording(): GenericResult;
    performStartRecordingOnNode(node: HTMLElement): boolean;
    /**
     * Returns the main section of a screen with app sections. This typically will not be the body therefore it needs to be inherited
     */
    private getMainSection;
    /**
     * Stops listening on changes on screen (mutation observer)
     */
    private stopRecordingChangesOnScreen;
    /**
     * Starts listening on changes on screen (mutation observer)
     */
    private startRecordingChangesOnScreen;
    /**
     * This method gets a  node, and iterates on it's parents until we find an element with Coverage Handler.
     * Then it start recording down from it
     * @param node
     */
    private startRecordingFromFirstParentWithCoverageHandler;
    /**
     * Populate node stack with nodes start from node until ancestor coverage handler was found
     * @param data
     */
    private findAncestorsCoverageHandler;
    /**
     * This method gets a  node, and iterates on it's parents until we find an element with Coverage Handler.
     * Then it start listening down from it
     * @param node
     */
    startListeningFromFirstParentWithCoverageHandler(node: HTMLElement): void;
    /**
     * Starts observe DOM changes such as removed/added nodes and/or attributes
     */
    private startListeningOnChanges;
    /**
     * Creating mutation observer for purposes of listening on changes
     */
    private CreateObserverForListeningOnChanges;
    /**
     * This method reports that element's attribute has changed to the platform
     * @param listeningElement
     * @param attribute
     * @param value new attribute value
     */
    protected reportAttributeChanged(listeningElement: ListeningElement, attribute: string, value: any): void;
    /**
     * Request from each frame under this screen to
     * start observe mutations
     */
    private startListeningOnChangesInFrames;
    /**
     * Request from each frame under this screen to
     * start observe mutations
     */
    private stopListeningInFrames;
    startListening(): GenericResult;
    stopListening(): GenericResult;
    /**
     * Stop listening on changes (mutation observer)
     */
    private stopListeningOnChanges;
    startCapturing(): GenericResult;
    /**
     * Enter into recording mode on the screen and its children
     */
    private performStartCapturingOnElementsInScreen;
    /**
     * Start capturing on document body
     */
    private startCapturingOnScreen;
    private stopCapturingOnScreen;
    stopCapturing(): GenericResult;
    private stopCapturingOnFrames;
    /**
     * Stop capturing by removing all elements with Capture Attr.
     */
    private stopHighlightElementsInScreen;
    /**
     * Create a selector from this coverage handler to childDomNode
     * @param childDomNode
     * @param useExistingSelector
     * @returns a selector
     */
    createSelectorToChild(childDomNode: HTMLElement, useExistingSelector: boolean): string;
    /**
     * Get the path to ourselves
     * @param useExistingSelector
     * @returns $(document.body) by default
     */
    protected createAnchorSelector(useExistingSelector: boolean): string;
    /**
     * concatenate ourself with the access to the child.
     * @param anchorSelector
     * @param partialSelector
     * @returns
     */
    protected concatenateSelectorParts(anchorSelector: string, partialSelector: string): string;
    createSelectorFromParentToChild(parentDomNode: HTMLElement, elementDomNode: HTMLElement): string;
    canAccessDirectly(): boolean;
    getNode(): GenericResult;
    /**
     * This method gets the selector part from the field section in the repository
     * @returns selector if a selector exists otherwise false
     */
    private getSelectorFromRepository;
    private createJQuerySelectorCommand;
    /**
     * Register screen for highlight
     * @param screenCoverageHandler
     * @param $elem document body
     * @param functionHandler event handler
     */
    private registerScreenForCapture;
    registerControlForHighlight(controlCoverageHandler: WebControlCoverageHandler, $elem: JQuery, functionHandler: Function): void;
    /**
     * register
     * @param key screen unique id
     * @param highlightElementData
     * @param $elem document body
     */
    private registerElementForHighlight;
    /**
     * Listen to the mouse move. We will get it also from the controls as it will bubble. However if we open a highlighter, it should not bubble.
     */
    private startHighlightingOnScreen;
    /**
     * Stops highlight
     */
    private stopHighlightOnScreen;
    /**
     * Mouse move event handler
     * @param event mouse move event data
     * @returns
     */
    private handleMouseMoveOnHighlight;
    /**
     * @param x coordinate
     * @param y coordinate
     * @returns the element for the specified x coordinate and the specified y coordinate.
     */
    elementFromPoint(x: number, y: number): Element;
    /**
     * Capture mouse move event handler
     * @param event
     * @returns
     */
    private handleHighlightMouseEvent;
    /**
     * Add or remove highlight to element
     * @param $highlightedElement
     * @returns
     */
    private highlightElement;
    /**
     * Add highlighter attribute to element
     * @param $elem
     * @returns
     */
    private addHighlighter;
    /**
     * Remove the current highlighted
     */
    private removeHighlighter;
    /**
     * Show red highlight according to show argument
     * @param $elem element to highlight
     * @param show if true show highlight otherwise hide highlight
     */
    highlightForSnapshot($elem: JQuery, show: boolean): void;
    /**
     * Remove current highlighted attribute element
     */
    removeHighlightAttribute(): void;
    /**
     * show highlight around element
     * @param $elem to highlight
     * @returns
     */
    private showHighlighter;
    /**
     * hide highlight around element
     * @returns
     */
    private hideHighlighter;
    /**
     * On a default web screen, which is HTML based, each element decides what to record.
     * Here we walk on the stack and each node decides if to record itself
     * @param nodesStack
     * @returns
     */
    performStartRecordingOnNodesStack(nodesStack: HTMLElement[]): GenericResult;
    /**
     * On a default web screen, which is HTML based, each element decides what to listen to.
     * Here we walk on the stack and each node decides if it needs to start listening.
     * @param nodesStack
     * @returns
     */
    protected performStartListeningOnNodesStack(nodesStack: HTMLElement[]): GenericResult;
    url(): string;
    protected screenTitle(): string;
    protected screenName(): string;
    walkOnChildren(parentNode: any, func: any): void;
    /**
     * Search and retrieve from memory a coverage handler which was set for this node.
     * @param node - the node we looking to find coverage for. The coverage returned can be from any coverage handler class.
     */
    private fetchCoverageHandlerFromNode;
    /**
     * Remove the coverage handler from memory include coverage attribute from element
     * @param node - This coverage handler node
     */
    protected removeCoverageHandlerFromNode(node: HTMLElement): void;
    /**
     * Retrieve a unique id from a given node
     * @param node The node we try to retrieve a unique id from
     */
    private getUniqueIdOfNode;
    /**
     * This method gets a node and returns it's coverageHandler.
     * @param node - the node to get it's coverage handler
     * @returns the suitable coverageHandler.
     */
    protected getCoverageHandlerForNode(node: HTMLElement): CoverageHandler;
    /**
     * This method gets a HTMLElement and HTMLElement array and starts the recording process on the
     * nodes in the array.
     * @param node -
     * @param nodesStack
     * @returns true
     */
    protected performStartRecordingOnNodeAndStack(node: HTMLElement, nodesStack: HTMLElement[]): boolean;
    /**
     * This method gets a HTMLElement and HTMLElement array and starts the listening process on the
     * nodes in the array.
     * @param node
     * @param nodesStack
     * @returns
     */
    performStartListeningOnNodeAndStack(node: HTMLElement, nodesStack: HTMLElement[]): boolean;
    performStartCapturingOnNode(node: any): boolean;
    createElementRepositoryNode(): any;
    /**
     * This method validates if the screen and the controls under it exist during execution.
     * @param elementPath - the path of te element to validate
     * @param lAction - the action to execute
     * @returns a GenericResult struct
     */
    validateScreenAndControls(elementPath: ElementPath, lAction: ExecutionLogicalAction): Promise<GenericResult>;
}
