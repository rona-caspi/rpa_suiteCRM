"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const WebControlCoverageHandler_1 = require("./WebControlCoverageHandler");
const LogicalAction_1 = require("@jacada-jbot/base/include/Model/LogicalAction");
const Log4jConfig_1 = require("@jacada-jbot/base/include/Utils/Log4jConfig");
const log = Log4jConfig_1.logFactory.getLogger("LinkButtonWebControlCoverageHandler");
/**
 * Coverage handler for a link element
 */
class LinkButtonWebControlCoverageHandler extends WebControlCoverageHandler_1.default {
    constructor() {
        super(...arguments);
        this.isPreventClickOnElement = true;
    }
    type() {
        return "WebLinkControl";
    }
    /**
     * This method fires a click event on the jquery object
     * @returns a GenericResult struct
     */
    click() {
        this.$currentNode[0].click();
        return this.returnSuccess(false);
    }
    /**
     * This method inserts the control to listening mode.
     * It adds an event listener on the jquery object to the click event.
     * @param listeningElement list of attributes/value we would like to listen to
     * @returns true if entering listening mode was successful.
     */
    executeStartListeningOnNode(listeningElement) {
        let elementPath = this.repositoryHandler.pathId;
        if (listeningElement.triggers != null && listeningElement.triggers.includes('clicked')) {
            //Register for change event for notify JBot that value change
            this.registerFirstOnEvent(this.$currentNode, "click", () => {
                this.reportTriggerFired(elementPath, 'clicked');
            });
        }
        return true;
    }
    /**
     * This method inserts the control to recording mode.
     * It adds an event listener on the jquery object to the click event.
     * @returns true if entering recording mode was successful.
     */
    executeStartRecordingOnNode() {
        // Instead of register registerFirstOnEvent like we do in other coverage handlers for recording
        //we are register this like we do in capturing 
        //So once we click on highlighted element we get here
        //pay attention to async await 
        this.registerControlForHighlight(this, this.$currentNode, async () => {
            // Notify action in recording
            log.debug(`URL: ${window.location.href}`);
            let lAction = new LogicalAction_1.default(this.click.name, "");
            await this.executeRecordedStep(lAction);
            this.$currentNode[0].click();
        });
        return true;
    }
    /**
     * This method executes capture on this element.
     * It registers it for the highlight will recognize it, and sets the callback function that will be called
     * when the element will be clicked during capture.
     * @returns true
     */
    executeStartCapturingOnNode() {
        this.registerControlForHighlight(this, this.$currentNode, (event) => {
            this.fetchLabelIfExists();
            this.executeStartCapturingClicked(event);
        });
        // Do we have label from parent?
        this.fetchLabelIfExists();
        return true;
    }
    /**
     * This method creates a selector from this coverage handler to childDomNode
     * @param childDomNode
     * @param useExistingSelector
     * @returns a selector
     */
    createSelectorToChild(childDomNode, useExistingSelector) {
        // Get our JQuery path from this element to the given child node
        let partialSelector = this.createSelectorFromParentToChild(this.domNode, childDomNode);
        // As we will find ourselves, this partial selector is enough
        return partialSelector;
    }
    createElementRepositoryNode() {
        let elementNode = super.createElementRepositoryNode();
        elementNode.config.nodeName = this.domNode.nodeName;
        return elementNode;
    }
    /**
     * @param $elem current DOM node
     * @returns If the button has value attribute, it's the text of the button
     */
    ownText($elem) {
        return this.ownDeepText($elem);
    }
    isRecordable() {
        return true;
    }
    isCapturable() {
        return true;
    }
    isListenable() {
        return true;
    }
    performCapturingOnChildren() {
        return false;
    }
    getAutoGeneratedIdPrefix() {
        return "Link";
    }
}
exports.default = LinkButtonWebControlCoverageHandler;
//# sourceMappingURL=LinkButtonWebControlCoverageHandler.js.map