"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ControlCoverageHandler_1 = require("@jacada-jbot/base/include/CoverageHandlers/ControlCoverageHandler");
const GenericResult_1 = require("@jacada-jbot/base/include/Model/GenericResult");
const $ = require("jquery");
const WebScreenCoverageHandler_1 = require("./WebScreenCoverageHandler");
const LabelWebControlCoverageHandler_1 = require("./LabelWebControlCoverageHandler");
const Log4jConfig_1 = require("@jacada-jbot/base/include/Utils/Log4jConfig");
const Constants_1 = require("../../Model/Constants");
const TypeGuards_1 = require("../../Utils/TypeGuards");
const log = Log4jConfig_1.logFactory.getLogger("WebControlCoverageHandler");
class WebControlCoverageHandler extends ControlCoverageHandler_1.default {
    constructor() {
        super(...arguments);
        /**
         * A name of value attribute (e.g. text for text input)
         *  */
        this.attributeValueName = "none";
        /**
         * JQuery element for this instance
         */
        this.$currentNode = null;
    }
    set domNode(node) {
        this._domNode = node;
    }
    get domNode() {
        return this._domNode;
    }
    executeAccessNodeWithSelector($previousResult) {
        // Previous result should be JQuery find result
        // Access the element using a selector
        let validationResult = this.validateRepositoryConfiguration();
        if (!validationResult.success)
            return validationResult;
        //after the validation we know the configuration is valid, and can use it.
        let selector = this.getSelectorFromRepository();
        if (!selector)
            return this.returnFailure("Selector was not found");
        let $elements;
        let selectionCmd = "";
        if ($previousResult) {
            if (this.repositoryHandler.config.nodeName === `#text`) {
                selectionCmd = `$previousResult${selector}`;
            }
            else {
                if (!selector.startsWith(`(`)) {
                    selector = `(${selector})`;
                }
                selectionCmd = `$previousResult.children${selector}`;
            }
            $elements = eval(selectionCmd);
        }
        else {
            selectionCmd = this.createJQuerySelectorCommand(selector);
            $elements = eval(selectionCmd);
        }
        if ($elements.length === 0) {
            return new GenericResult_1.GenericResult(false, `Selector ${selectionCmd} not found`, null);
        }
        return this.returnSuccess({ accessResult: $elements });
    }
    canAccessDirectly() {
        return this.canAccessDirectlyFromRepository(this.repositoryHandler);
    }
    canAccessDirectlyFromRepository(repositoryHandler) {
        let config = repositoryHandler.config;
        if (!config) {
            log.error("No config for JQuery control");
            return false;
        }
        let fields = config.fields;
        if (!fields) {
            log.error("No fields for JQuery config");
            return false;
        }
        if (fields.length === 0) {
            log.error("Empty fields for JQuery config");
            return false;
        }
        // By default we perform get on first field. Other controls can change it.
        let field = fields[0];
        let selector = field.selector;
        if (selector) {
            // We have a selector. It need to be marked as direct access.
            // TBD: Support manual _
            return typeof field.directAccess !== "undefined";
        }
        else {
            // id and name are direct access without parent
            if (field.id || field.name) {
                return true; // We can access directly
            }
            else {
                return false;
            }
        }
    }
    createRepositoryHandler() {
        // We create our element and ask parent to add it and give us back the repository handler.
        let repositoryNode = this.createElementRepositoryNode();
        if (!repositoryNode) {
            log.trace("createRepositoryHandler: Empty repository node created");
            return null;
        }
        log.trace(`createRepositoryHandler: repository node is: ${JSON.stringify(repositoryNode)}`);
        // Add ourselves under the parent repository
        return this.parentCoverageHandler.addChildRepositoryNodeToOurselvesRecursively(repositoryNode, this);
    }
    /**
     * Check if RepositoryHandler has a valid configuration field
     * @returns true if it has and it is not empty otherwise false
     */
    validateRepositoryConfiguration() {
        let config = this.repositoryHandler.config;
        if (!config)
            return this.returnFailure("No config for JQuery control");
        //
        // Config structure:
        // {
        //    fields: [
        //       {
        //          selector: '(".controlId")'
        //       }
        //    ]
        // }
        let fields = config.fields;
        if (!fields)
            return this.returnFailure("No fields for JQuery config");
        if (fields.length === 0)
            return this.returnFailure("Empty fields for JQuery config");
        return this.returnSuccess(config);
    }
    /**
     * This method gets the selector part from the field section in the repository
     * @returns selector if a selector exists otherwise false
     */
    getSelectorFromRepository() {
        // Getting our configuration. This is specific for JQuery.
        const config = this.repositoryHandler.config;
        const fields = config.fields;
        // By default we perform get on first field. Other controls can change it.
        const field = fields[0];
        return field.selector;
    }
    /**
     * This method sets the basic and common fields in the repository for each control
     * @returns
     */
    createBasicElementRepositoryNode() {
        let repositoryNode = super.createBasicElementRepositoryNode();
        repositoryNode.config.fields = []; // Web elements can have multiple fields.
        //In case domNode type is text ,domNode has attribute function does not exists
        if (this.domNode.hasAttribute && this.domNode.hasAttribute("id")) {
            // By default the name is the id
            repositoryNode.id = this.$currentNode.attr("id");
            repositoryNode.name = this.getName(repositoryNode);
        }
        else {
            repositoryNode.id = Constants_1.BaseConstants.AUTO_GENERATE_ID_PREFIX; // Will be updated once attached to base
            repositoryNode.name = this.getName(repositoryNode);
        }
        const field = { selector: this.createRepositoryNodeSelector(this.domNode) };
        repositoryNode.config.fields.push(field);
        return repositoryNode;
    }
    createElementRepositoryNode() {
        let repositoryNode = this.createBasicElementRepositoryNode();
        repositoryNode.type = this.customCoverageHandler.type;
        this.customCoverageHandler.updateElementRepositoryNode(repositoryNode);
        this.standardizeRepositoryNodeFields(repositoryNode);
        return repositoryNode;
    }
    /**
     * This method converts repository node fields into standard fields that acceptable for RPA
     * @param repositoryNode a repository node after it modified by coverage writer
     */
    standardizeRepositoryNodeFields(repositoryNode) {
        repositoryNode.name = this.cleanName(repositoryNode.name);
        repositoryNode.id = this.cleanId(repositoryNode.id);
    }
    /**
     * Create selector recursively, if parent of elementDomNode has an id use it
     * otherwise go to elementDomNode parent until body element
     * @remark This function might use name attribute of elementDomNode as unique id.
     * If your app contains multiple elements with same name attribute you should override this function
     * @param elementDomNode current DOM node
     * @returns
     */
    createRepositoryNodeSelector(elementDomNode) {
        // Node has no id or name.
        // Find a parent where we can anchor from.
        const parentDomNode = elementDomNode.parentElement;
        if (parentDomNode && elementDomNode.nodeName !== "BODY") {
            let partialSelector;
            // If has id, use it.
            if (elementDomNode.hasAttribute && elementDomNode.hasAttribute("id")) {
                const id = elementDomNode.getAttribute("id");
                partialSelector = `(\"#${id}\")`;
            }
            else {
                // Get our JQuery path from this element.
                partialSelector = this.createSelectorFromParentToChild(parentDomNode, elementDomNode);
            }
            let anchorSelector;
            if (this.parentCoverageHandler.customCoverageHandler && !this.parentCoverageHandler.customCoverageHandler.isNodeToBeAddedToRepository) {
                const parentCH = this.parentCoverageHandler;
                anchorSelector = parentCH.createRepositoryNodeSelector(parentCH.customCoverageHandler.node[0]);
            }
            else if (!this.parentCoverageHandler.isNodeToBeAddedToRepository) {
                // if the parent doesn't have a node in the repository, continue to build the path from the parent
                const parentCH = this.parentCoverageHandler;
                anchorSelector = parentCH.createRepositoryNodeSelector(parentCH.$currentNode[0]);
            }
            return this.concatenateSelectorParts(anchorSelector, partialSelector);
        }
    }
    /**
     * Create selector for a child
     * @param childDomNode A child we would like to create a selector
     * @param useExistingSelector If true take existing selector from repository handler otherwise go to parent
     * @returns
     */
    createSelectorToChild(childDomNode, useExistingSelector) {
        // Get our JQuery path from this element to the given child node
        let partialSelector = this.createSelectorFromParentToChild(this.domNode, childDomNode);
        // Get the path to ourselves
        let anchorSelector = this.createAnchorSelector(useExistingSelector);
        // concatenate ourself with the access to the child.
        return this.concatenateSelectorParts(anchorSelector, partialSelector);
    }
    /**
     * Create an anchor selector for control coverage that not override createSelectorToChild function
     * @param useExistingSelector if true use selector
     * @returns
     */
    createAnchorSelector(useExistingSelector) {
        // If we already have a selector, use it.
        if (useExistingSelector && this.repositoryHandler && this.repositoryHandler.config && this.repositoryHandler.config.selector) {
            return this.repositoryHandler.config.selector;
        }
        // If has id or name, it's anchor from there.
        if (this.domNode.hasAttribute("id")) {
            const id = this.domNode.getAttribute("id");
            return `(\"#${id}\")`;
        }
        else {
            // Otherwise, continue to build the path from the parent
            if (!(this.parentCoverageHandler instanceof ControlCoverageHandler_1.default)) {
                //TBD Exception
                return "Coverage handler is not control or screen!";
            }
            const parentCoverageHandler = this.parentCoverageHandler;
            return parentCoverageHandler.createSelectorToChild(this.domNode, useExistingSelector);
        }
    }
    concatenateSelectorParts(anchorSelector, partialSelector) {
        if (anchorSelector && anchorSelector.length > 0) {
            return `${anchorSelector}.children${partialSelector}`;
        }
        else {
            return partialSelector;
        }
    }
    /**
     * This method creates a selector command that finds the element node on parent element.
     * By default we do it by finding the element type and it's index. So, lets walk
     * @param parentDomNode parent of current DOM element
     * @param elementDomNode current DOM element
     * @returns the created selector
     */
    createSelectorFromParentToChild(parentDomNode, elementDomNode) {
        let nodeTagName = elementDomNode.nodeName;
        let indexInParent = 0;
        this.walkOnChildren(parentDomNode, function (node) {
            if (node === elementDomNode) {
                return false; // Stop looping
            }
            else {
                if (node.nodeName === nodeTagName) {
                    indexInParent++;
                }
                return true;
            }
        });
        // Return a JQuery selector based on the index
        return `('${nodeTagName}').eq(${indexInParent})`;
    }
    /**
     * Get a name for this control
     * @param $domNode
     * @param repositoryNode
     * @returns the name
     */
    getName(repositoryNode) {
        const node = this.customCoverageHandler.node;
        if (node[0].hasAttribute && node[0].hasAttribute("name")) {
            return node.attr("name");
        }
        let name = this.cleanName(this.ownText(node));
        if (name.length > 0)
            return name;
        // If we have label attached, take it.
        name = this.cleanName(this.getNameFromLabel());
        if (name.length > 0)
            return name;
        // Try to retrieve the name of an element by looking for text of the parent. This is the default. Might be different in other elements
        name = this.cleanName(this.getNameFromParent());
        if (name.length > 0)
            return name;
        // Before giving up, try to take the id if it's already given (notice that we check explicity for Constants.AUTO_GENERATE_ID_PREFIX and not startsWith)
        if (repositoryNode.id && repositoryNode.id.length > 0 && repositoryNode.id !== Constants_1.BaseConstants.AUTO_GENERATE_ID_PREFIX)
            return repositoryNode.id;
        return this.nodeNoName();
    }
    /**
     * Get name from a label current DOM node
     * @param $domNode current DOM node
     * @param repositoryNode
     * @returns the name
     */
    getNameFromLabel() {
        if (this.labelCoverageHandler) {
            let labelCoverageHandler = this.labelCoverageHandler;
            let name = labelCoverageHandler.getNameForPointed();
            return name;
        }
        else {
            return "";
        }
    }
    /**
     * Get name of parent DOM node
     * @param $domNode
     * @returns the name
     */
    getNameFromParent() {
        const $parent = this.getParentNode();
        if ($parent.length === 0)
            return "";
        const name = this.ownText($parent);
        if (name.length === 0)
            return "";
        return name;
    }
    getParentNode() {
        return this.customCoverageHandler.node.parent();
    }
    /**
     * This method returns a default value for the element in case we didn't find any name
     * @remark This function should be override
     * @returns
     */
    nodeNoName() {
        return "No Name";
    }
    /**
     * Add a $ sign as a prefix to selector
     * @param selector
     * @returns The selector with $ sign
     */
    createJQuerySelectorCommand(selector) {
        if (selector.startsWith("$"))
            return selector;
        selector = "$" + selector;
        return selector;
    }
    /**
     * Try to start listening on this coverage handler
     * @returns True if this coverage start listening successfully or coverage is not listenable, Otherwise false
     */
    performControlStartListening() {
        if (((0, TypeGuards_1.isControl)(this.customCoverageHandler) && this.customCoverageHandler.isListenable()) || (0, TypeGuards_1.isTable)(this.customCoverageHandler)) {
            let listeningElement = this.applicationCoverageHandler.getListeningElement(this.repositoryHandler.pathId);
            if (listeningElement) {
                if (!this.executeStartListening(listeningElement))
                    return false;
            }
        }
        return true;
    }
    /**
     * This function register controlCoverageHandler on highlight, meaning that only registered element will be highlighted
     * during capturing and once they been clicked the functionHandler will be invoked
     * @param controlCoverageHandler that will be register for highlight
     * @param $elem jquery DOM node object
     * @param functionHandler event handler
     */
    registerControlForHighlight(controlCoverageHandler, $elem, functionHandler) {
        // This control wants to handle capture. Should be handled by the screen
        if (this.parentCoverageHandler instanceof WebScreenCoverageHandler_1.default) {
            let parentCoverageHandler = this.parentCoverageHandler;
            parentCoverageHandler.registerControlForHighlight(controlCoverageHandler, $elem, functionHandler);
        }
        else {
            let parentCoverageHandler = this.parentCoverageHandler;
            parentCoverageHandler.registerControlForHighlight(controlCoverageHandler, $elem, functionHandler);
        }
    }
    /**
     * Get the text contents of element DOM node
     * @param $elem
     * @returns
     */
    ownText($elem) {
        if (!$elem)
            $elem = $(this.domNode);
        return $elem
            .contents()
            .filter(function () {
            return this.nodeType === Node.TEXT_NODE;
        })
            .text();
    }
    getElementCoordinates() {
        // Get the width and height of the element
        let width = Math.round(this.$currentNode.outerWidth());
        let height = Math.round(this.$currentNode.outerHeight());
        // Find the element position
        let offset = this.$currentNode.offset();
        // Get the containing document
        let ownerDocument = this.$currentNode.prop("ownerDocument");
        // Get the top and left of the element
        let top = Math.round(offset.top - ownerDocument.documentElement.scrollTop);
        let left = Math.round(offset.left - ownerDocument.documentElement.scrollLeft);
        return [left, top, width, height];
    }
    /**
     * Highlight element DOM node with red color before snapshot
     * @param $elem DOM node
     * @param show
     */
    highlightBeforeSnapshot($elem, show) {
        if (this.parentCoverageHandler instanceof WebScreenCoverageHandler_1.default) {
            let parentCoverageHandler = this.parentCoverageHandler;
            parentCoverageHandler.highlightForSnapshot($elem, show);
        }
        else {
            let parentCoverageHandler = this.parentCoverageHandler;
            parentCoverageHandler.highlightBeforeSnapshot($elem, show);
        }
    }
    /**
     * This method prepares the recorded step to be send to the platform: it merges the repository and reports the new tree,
     * it creates the snapshot of the element and reports the recorded step.
     * @param lAction - the action that was recorded
     */
    async executeRecordedStep(lAction) {
        try {
            // This element need to be saved
            // We need to make sure we have the path and the repository to support it
            // and merge what we found now with the repository
            this.validateAndMergeRepository();
            // Report JBot about the changes in the repository
            this.reportTreeChanged();
        }
        catch (error) {
            this.platformDriver.throwException(error, "ReportTreeChangedException");
        }
        let elementCoordinates;
        try {
            log.debug(`getElementCoordinates`);
            elementCoordinates = this.getElementCoordinates();
            log.debug(`got element coordinates`);
            log.debug(`createElementSnapshot`);
            await this.createElementSnapshot((snapshot) => {
                log.debug(`element snapshot created`);
                try {
                    // Report JBot about the recording step
                    this.reportRecordedStep(lAction, snapshot, elementCoordinates);
                }
                catch (error) {
                    this.platformDriver.throwException(error, "ReportRecordedStepException");
                }
            });
        }
        catch (error) {
            log.error("cannot create element snapshot");
            try {
                // Report JBot about the recording step
                this.reportRecordedStep(lAction);
            }
            catch (error) {
                this.platformDriver.throwException(error, "ReportRecordedStepException");
            }
        }
    }
    async createElementSnapshot(callback) {
        return new Promise((resolve, reject) => {
            log.debug(`createElementSnapshot in chrome`);
            log.debug(`highlighting red`);
            this.highlightBeforeSnapshot(this.$currentNode, true);
            log.debug(`highlighting red done`);
            this.platformDriver.createSnapshot((res) => {
                log.debug(`removing highlight`);
                this.highlightBeforeSnapshot(this.$currentNode, false);
                if (res && res.snapshot) {
                    log.debug(`snapshot created`);
                    let result = res.snapshot;
                    callback && callback(result);
                    resolve();
                }
                else {
                    reject("snapshot not created properly");
                }
            });
        });
    }
    getNode($previousResult) {
        log.trace(`Inside getNode`);
        return this.executeAccessNodeWithSelector($previousResult);
    }
    setNode(node) {
        log.trace(`Inside setNode`);
        this.domNode = node;
        this.$currentNode = $(node);
        if ((0, TypeGuards_1.isWebControl)(this.customCoverageHandler)) {
            this.customCoverageHandler.node = $(node);
        }
    }
    executeStartListening(listeningElement) {
        if (!super.executeStartListening(listeningElement))
            return false;
        if ((0, TypeGuards_1.isWebControl)(this.customCoverageHandler)) {
            this.customCoverageHandler.node.data("pathId", this.repositoryHandler.pathId);
        }
        listeningElement.attributes.forEach((attribute) => {
            // get attributes initial value
            const initialValueResult = this.customCoverageHandler[attribute.getter].apply(this.customCoverageHandler);
            if (initialValueResult.success) {
                this.reportInitialValue(initialValueResult.data, attribute.changeEventSubscriber.name);
            }
        });
        this.listeningTriggersMap.forEach((funcName) => {
            funcName.forEach((func) => {
                //start listening for attribute changes
                if ((0, TypeGuards_1.isControl)(this.customCoverageHandler)) {
                    this.customCoverageHandler[func].apply(this.customCoverageHandler);
                }
            });
        });
        return true;
    }
    performStartRecording() {
        if (this.customCoverageHandler instanceof LabelWebControlCoverageHandler_1.default) {
            this.applicationData.setScreenTopicData("Labels", Constants_1.Constants.PARENT_ID, this.customCoverageHandler);
        }
        if ((0, TypeGuards_1.isControl)(this.customCoverageHandler)) {
            const webCustom = this.customCoverageHandler;
            // Make the code per element that execute the start recording
            if (webCustom.isRecordable()) {
                this.fetchLabelIfExists();
                // Record it
                if (!webCustom.startRecording())
                    return this.returnFailure("Error in performStartRecording");
                // Make sure we have highlight around it
                this.registerControlForHighlight(this, this.$currentNode, null);
            }
            //This method records on children, if the performRecordingOnChildren returns true
            if (webCustom.areChildrenRecordable()) {
                this.walkOnChildren(this.domNode, (node) => {
                    // in walkOnChildren we check that the function returns true otherwise, we don't continue to the next sibling
                    return this.performStartRecordingOnNode(node);
                });
            }
            if (this.customCoverageHandler instanceof LabelWebControlCoverageHandler_1.default) {
                this.applicationData.deleteScreenTopicData("Labels", Constants_1.Constants.PARENT_ID);
            }
        }
        return this.returnSuccess("");
    }
    /**
     * This method starts the recording process on new element that were added to the screen by the
     * mutation observer.
     * @param nodesStack - an array of the new HTMLElement to start recording on
     * @returns a GenericResult struct
     */
    performStartRecordingOnNodesStack(nodesStack) {
        if ((0, TypeGuards_1.isControl)(this.customCoverageHandler)) {
            const webCustom = this.customCoverageHandler;
            // Make the code per element that execute the start recording
            if (webCustom.isRecordable()) {
                // Record it
                if (!webCustom.startRecording())
                    return this.returnFailure("Error in performStartRecording");
                // Make sure we have highlight around it
                this.registerControlForHighlight(this, this.$currentNode, null); // In recording, we do not register to event, just for capture highlight
            }
            if (webCustom.areChildrenRecordable()) {
                if (nodesStack.length === 0) {
                    return this.returnSuccess("");
                }
                let node = nodesStack.pop();
                this.performStartRecordingOnNodeAndStack(node, nodesStack);
            }
        }
        return this.returnSuccess("");
    }
    /**
     *  This method starts the listening process on new element that were added to the screen by the
     * mutation observer.
     * @param nodesStack - an array of the new HTMLElement to start recording on
     * @returns a GenericResult struct
     */
    performStartListeningOnNodesStack(nodesStack) {
        if (!this.performControlStartListening())
            return this.returnFailure("Error in performControlStartListening");
        // Make the code per element that execute the start recording
        if (nodesStack.length === 0) {
            return this.returnSuccess("");
        }
        let node = nodesStack.pop();
        this.performStartListeningOnNodeAndStack(node, nodesStack);
        return this.returnSuccess("");
    }
    /**
     * This method starts the process of capturing for this element and, in case the performCapturingOnChildren is true,
     * it also iterate on its children to start capturing on them also.
     * @returns
     */
    performStartCapturing() {
        if (this.customCoverageHandler instanceof LabelWebControlCoverageHandler_1.default) {
            this.applicationData.setScreenTopicData("Labels", Constants_1.Constants.PARENT_ID, this.customCoverageHandler);
        }
        if (this.customCoverageHandler.isCapturable()) {
            this.fetchLabelIfExists();
            // Make the code per element that execute the start capturing
            this.registerControlForHighlight(this, this.$currentNode, (event) => {
                this.executeStartCapturingClicked(event);
            });
        }
        if (this.customCoverageHandler.areChildrenCapturable()) {
            this.walkOnChildren(this.domNode, (node) => {
                return this.performStartCapturingOnNode(node);
            });
        }
        if (this.customCoverageHandler instanceof LabelWebControlCoverageHandler_1.default) {
            this.applicationData.deleteScreenTopicData("Labels", Constants_1.Constants.PARENT_ID);
        }
        return this.returnSuccess("");
    }
    walkOnChildren(parentNode, func, includeTextNodes = false) {
        if (!parentNode) {
            log.trace("walkOnChildren but no parentNode");
            return;
        }
        let node = parentNode.firstChild;
        if (!node) {
            log.trace(`No first child for ${parentNode.nodeName}`);
            return;
        }
        if (node)
            do {
                log.trace(`nodeType=${node.nodeType}`);
                if (node.nodeType === Node.ELEMENT_NODE || (includeTextNodes && node.nodeType === Node.TEXT_NODE && !this.checkForElementNodeSiblings(parentNode))) {
                    if (!func(node)) {
                        break;
                    }
                }
            } while ((node = node.nextSibling));
    }
    /**
     * This method checks if the TEXT_NODE element has ELEMENT_NODE siblings
     * @param parentNode
     * @returns true if it as ELEMENT_NODE siblings, false otherwise
     */
    checkForElementNodeSiblings(parentNode) {
        let node = parentNode.firstChild;
        let foundElementNode = false;
        if (node)
            do {
                if (node.nodeType === Node.ELEMENT_NODE) {
                    foundElementNode = true;
                    break;
                }
            } while ((node = node.nextSibling));
        if (foundElementNode)
            return true;
        return false;
    }
    performStartRecordingOnNode(node) {
        let controlCoverageHandler = this.getCoverageHandlerForNode(node);
        if (controlCoverageHandler) {
            // Let the coverage prepare for the recording
            controlCoverageHandler.performStartRecording();
        }
        // Return code is important to continue the walking on children
        return true;
    }
    /**
     * Search and retrieve from memory a coverage handler which was set for this node.
     * @param node - the node we looking to find coverage for. The coverage returned can be from any coverage handler class.
     */
    fetchCoverageHandlerFromNode(node) {
        const uniqueId = $(node).data(Constants_1.Constants.JBOT_UNIQUE_ID_KEY);
        if (!uniqueId) {
            return null;
        }
        return this.fetchCoverageHandlerFromUniqueId(uniqueId);
    }
    /**
     * This method gets a node and returns it's coverageHandler.
     * @param node - the node to get it's coverage handler
     * @returns the suitable coverageHandler.
     */
    getCoverageHandlerForNode(node) {
        let coverageHandler = this.fetchCoverageHandlerFromNode(node);
        if (coverageHandler) {
            return coverageHandler;
        }
        coverageHandler = this.getCoverageHandler(node);
        if (coverageHandler == null) {
            return null;
        }
        const uniqueId = $(node).data(Constants_1.Constants.JBOT_UNIQUE_ID_KEY);
        coverageHandler.saveCoverageHandlerForUniqueId(uniqueId);
        node.setAttribute(Constants_1.Constants.JBOT_COVERAGE_HANDLER_ATTR, "");
        return coverageHandler;
    }
    getCoverageHandler(node) {
        // Need to try get it from type and factory
        // Get the node type (web type)
        let result = this.getCoverageHandlerByNode(node);
        if (!result.success) {
            return null;
        }
        let coverageHandler = result.data.coverageHandler;
        // Set the DOM node for this coverage
        coverageHandler.setNode(node);
        return coverageHandler;
    }
    /**
     * This method gets a HTMLElement and HTMLElement array and starts the recording process on the
     * nodes in the array.
     * @param node -
     * @param nodesStack
     * @returns true
     */
    performStartRecordingOnNodeAndStack(node, nodesStack) {
        // Prepare node for recording. Need to find the coverage handler for this node to execute it.
        let controlCoverageHandler = this.getCoverageHandlerForNode(node);
        if (controlCoverageHandler) {
            // Let the coverage prepare for the recording
            controlCoverageHandler.performStartRecordingOnNodesStack(nodesStack);
        }
        return true;
    }
    /**
     * This method gets a HTMLElement and HTMLElement array and starts the listening process on the
     * nodes in the array.
     * @param node
     * @param nodesStack
     * @returns
     */
    performStartListeningOnNodeAndStack(node, nodesStack) {
        // Prepare node for recording. Need to find the coverage handler for this node to execute it.
        let controlCoverageHandler = this.getCoverageHandlerForNode(node);
        if (controlCoverageHandler) {
            controlCoverageHandler.repositoryHandler = controlCoverageHandler.createRepositoryHandler();
            // Let the coverage prepare for the recording
            controlCoverageHandler.performStartListeningOnNodesStack(nodesStack);
        }
        return true;
    }
    performStartCapturingOnNode(node) {
        // Prepare node to be captured. Need to find the coverage handler for this node to execute it.
        let controlCoverageHandler = this.getCoverageHandlerForNode(node);
        if (controlCoverageHandler) {
            // Let the coverage prepare for the capture
            controlCoverageHandler.performStartCapturing();
        }
        // Return code is important to continue the walking on children
        return true;
    }
    cleanId(name) {
        return name.replace(/\W/g, "");
    }
    cleanName(name) {
        return name
            .replace(/[^A-Za-z0-9_ ]/g, "")
            .replace(/[ ]+/g, " ")
            .trim();
    }
    /**
     * Each coverage handler has label coverage handler property
     * This function assign it to current coverage handler
     */
    fetchLabelIfExists() {
        if (this.labelCoverageHandler)
            return;
        let labelCoverageHandler = this.applicationData.getScreenTopicData(Constants_1.Constants.LABELS_TOPIC, Constants_1.Constants.PARENT_ID);
        if (labelCoverageHandler) {
            this.labelCoverageHandler = labelCoverageHandler;
        }
        else {
            if (this.domNode.hasAttribute("id")) {
                const id = this.domNode.getAttribute("id");
                labelCoverageHandler = this.applicationData.getScreenTopicData(Constants_1.Constants.LABELS_TOPIC, id);
                if (labelCoverageHandler) {
                    this.labelCoverageHandler = labelCoverageHandler;
                }
            }
        }
    }
    /**
     * collect all coverage handler fields and store their path into fieldsPathIds
     * @param fieldsPathIds array of fields path id
     */
    collectFieldsPathIds(fieldsPathIds) {
        if (this.customCoverageHandler) {
            const webCustom = this.customCoverageHandler;
            //If it's not a tableCell
            if (webCustom.isCapturable()) {
                const nodeHasChildren = this.nodeHasChildrenElements();
                if (!nodeHasChildren || (nodeHasChildren && !webCustom.areChildrenCapturable())) {
                    this.validateAndMergeRepository();
                    fieldsPathIds.push(this.repositoryHandler.pathId);
                }
            }
            if (webCustom.areChildrenCapturable()) {
                this.walkOnChildren(this.domNode, (node) => {
                    return this.collectFieldsPathIdsOnNode(node, fieldsPathIds);
                }, true);
            }
        }
        else {
            //It's a tableCell, we continue to children
            this.walkOnChildren(this.domNode, (node) => {
                return this.collectFieldsPathIdsOnNode(node, fieldsPathIds);
            }, true);
        }
    }
    /**
     * This method checks if the node has children that are not text nodes, in order to determine if it's a leaf.
     * @returns true, if it has children other than text nodes, false otherwise
     */
    nodeHasChildrenElements() {
        const foundChildElement = this.customCoverageHandler.node.contents().filter(function () {
            return this.nodeType == Node.ELEMENT_NODE;
        });
        return foundChildElement.length > 0;
    }
    /**
     * TODO:Add description
     * @param node DOM node
     * @param fieldsPathIds
     * @returns
     */
    collectFieldsPathIdsOnNode(node, fieldsPathIds) {
        var _a;
        let controlCoverageHandler;
        if (node.nodeType === Node.TEXT_NODE) {
            //Ignore line with white spaces & new lines symbols like \n
            if (node.textContent.trim().length === 0 || ((_a = this.customCoverageHandler) === null || _a === void 0 ? void 0 : _a.type) == "Label")
                return true;
            controlCoverageHandler = this.getCoverageHandler(node);
        }
        else {
            controlCoverageHandler = this.getCoverageHandlerForNode(node);
        }
        controlCoverageHandler.collectFieldsPathIds(fieldsPathIds);
        return true;
    }
    /**
     * This method reports that element's attribute has changed to the platform
     * @param listeningElement
     * @param attribute
     * @param value
     */
    reportAttributeChanged(listeningElement, attribute, value) {
        let elementPath = listeningElement.path;
        if (listeningElement.lastStatus.has(attribute)) {
            let lastValue = listeningElement.lastStatus.get(attribute);
            // If we already reported and it's false, no need to report
            if (lastValue != value) {
                // Changed
                this.platformDriver.reportChangedElement(elementPath, attribute, value);
                listeningElement.lastStatus.set(attribute, value);
            }
        }
        else {
            // Initial one
            this.platformDriver.reportChangedElement(elementPath, attribute, value);
            listeningElement.lastStatus.set(attribute, value); // Initially set
        }
    }
}
exports.default = WebControlCoverageHandler;
//# sourceMappingURL=WebControlCoverageHandler.js.map