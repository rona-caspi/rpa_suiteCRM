"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const WebControlCoverageHandler_1 = require("./WebControlCoverageHandler");
const GenericResult_1 = require("@jacada-jbot/base/include/Model/GenericResult");
const TableBodyCellWebControlCoverageHandler_1 = require("./TableBodyCellWebControlCoverageHandler");
const ElementPath_1 = require("@jacada-jbot/base/include/Model/ElementPath");
const Constants_1 = require("@jacada-jbot/base/include/Model/Constants");
const Log4jConfig_1 = require("@jacada-jbot/base/include/Utils/Log4jConfig");
const WebCustomTableControlCoverageHandler_1 = require("./WebCustomTableControlCoverageHandler");
const log = Log4jConfig_1.logFactory.getLogger("TableRowWebControlCoverageHandler");
class TableRowWebControlCoverageHandler extends WebControlCoverageHandler_1.default {
    /**
     * This method executes the requested get actions on fields inside a table row
     * @param fields the data containing the pathId and attributes
     * @returns a GenericResult struct with the required data inside the Data (of the GenericResult)
     */
    executeGetOnRow(fields) {
        log.trace(`Inside executeGetOnRow`);
        let dataResponse = {};
        for (let i = 0; i < fields.length; i++) {
            const field = fields[i];
            log.debug(`Getting data for element with path: ${field.path}`);
            const elementPath = new ElementPath_1.default(field.path);
            let result = this.createCellCoverageHandler(elementPath);
            // cell does not exist
            if (!result.success) {
                dataResponse[field.key] = { exists: false };
            }
            else {
                const cellCoverageHandler = result.data;
                result = cellCoverageHandler.executeGetOnCell(elementPath, field.attributes);
                if (!result.success)
                    return result;
                dataResponse[field.key] = result.data;
            }
        }
        return this.returnSuccess(dataResponse);
    }
    /**
     * This method executes the requested set actions on fields inside a table row
     * @param {FieldsSetData[]} fields - holds the data to set on each cell
     * @return {*}  {GenericResult}
     * @memberof TableRowWebControlCoverageHandler
     */
    executeSetOnRow(fields) {
        log.trace(`Inside executeSetOnRow`);
        for (let i = 0; i < fields.length; i++) {
            const field = fields[i];
            log.debug(`Setting data for element with path: ${field.path}`);
            const elementPath = new ElementPath_1.default(field.path);
            let result = this.createCellCoverageHandler(elementPath);
            if (!result.success)
                return result;
            let cellCoverageHandler = result.data;
            result = cellCoverageHandler.executeSetOnCell(elementPath, field);
            if (!result.success)
                return result;
        }
        return this.returnSuccess();
    }
    /**
     * This method creates the cell coverage handler inside the row
     * @private
     * @param {ElementPath} elementPath - the path to the cell
     * @return {*}  {GenericResult} the created cell coverage handler inside GenericResult data
     */
    createCellCoverageHandler(elementPath) {
        const result = this.getNextPathRepository(elementPath);
        if (!result.success)
            return new GenericResult_1.GenericResult(false, `Could not find element ${elementPath._elementPathId} in repository`, Constants_1.Constants.ELEMENT_NOT_FOUND_EXCEPTION);
        const elementRepositoryHandler = result.data.repositoryHandler;
        const cellCoverageHandler = (this.factory.createCoverageHandlerByType(this.platformDriver, elementRepositoryHandler, this.applicationData, this, this.factory, elementRepositoryHandler.type, this.applicationCoverageHandler));
        const cellNode = cellCoverageHandler.getNode(this.$currentNode);
        if (!cellNode.success)
            return new GenericResult_1.GenericResult(false, `Could not find element ${elementPath._elementPathId}`, Constants_1.Constants.ELEMENT_NOT_FOUND_EXCEPTION);
        cellCoverageHandler.setNode(cellNode.data.accessResult);
        return this.returnSuccess(cellCoverageHandler);
    }
    /**
     * This method gets a criteria and checks if this row meets the criteria
     * @param {CriteriaData} criteria
     * @return {*}  {GenericResult} a GenericResult struct with value true in the data if the row meets the criteria, false otherwise
     * @memberof TableRowWebControlCoverageHandler
     */
    checkRowCriteria(criteria) {
        log.trace("Inside checkRowCriteria");
        const elementPath = new ElementPath_1.default(criteria.path);
        const result = this.getNextPathRepository(elementPath);
        if (!result.success)
            return result;
        const elementRepositoryHandler = result.data.repositoryHandler;
        const cellCoverageHandler = (this.factory.createCoverageHandlerByType(this.platformDriver, elementRepositoryHandler, this.applicationData, this, this.factory, elementRepositoryHandler.type, this.applicationCoverageHandler));
        const cellNode = cellCoverageHandler.getNode(this.$currentNode);
        if (!cellNode.success)
            return new GenericResult_1.GenericResult(false, `Could not find element ${elementPath._elementPathId}`, Constants_1.Constants.ELEMENT_NOT_FOUND_EXCEPTION);
        cellCoverageHandler.setNode(cellNode.data.accessResult);
        if (!cellCoverageHandler.checkFieldData(elementPath, criteria))
            return this.returnSuccess(false);
        else
            return this.returnSuccess(true);
    }
    /**
     * Walking on each table data and find fields and add their path into fieldsPathIds
     * @param fieldsPathIds
     * @returns
     */
    collectFieldsPathIds(fieldsPathIds) {
        // Currently we support only one body row on single selection
        const tableCoverageHandler = this.parentCoverageHandler;
        if (tableCoverageHandler.customCoverageHandler.tableType === WebCustomTableControlCoverageHandler_1.default.TABLE_TYPE_SINGLE_SELECTION) {
            this.walkOnChildren(this.domNode, (tableDataNode) => {
                const cellNode = tableCoverageHandler.customCoverageHandler.getCell(tableDataNode);
                const tableDataCoverageHandler = new TableBodyCellWebControlCoverageHandler_1.default(this.platformDriver, null, this.applicationData, this, this.factory, this.applicationCoverageHandler);
                tableDataCoverageHandler.setNode(cellNode);
                tableDataCoverageHandler.collectFieldsPathIds(fieldsPathIds);
                this.setFieldName(tableDataNode, tableDataCoverageHandler);
                return true;
            });
        }
        else {
            //TODO: Handle grid
            // for (let i = 0; i < $trs.length; i++) {
            //     this.performStartCapturingOnBody(i, $trs[i]);
            // }
        }
        return false;
    }
    setFieldName(tableDataNode, tableDataCoverageHandler) {
        if (!tableDataCoverageHandler.repositoryHandler)
            return;
        const columnNumber = this.findColumnNumber(tableDataNode);
        const columnName = this.getColumnName(columnNumber);
        const numberOfFields = tableDataCoverageHandler.repositoryHandler.children.length;
        const fieldName = this.customCoverageHandler.getFieldName(columnName, columnNumber);
        if (numberOfFields === 1) {
            tableDataCoverageHandler.repositoryHandler.children[0].name = fieldName;
        }
        else {
            for (let index = 0; index < numberOfFields; index++) {
                const child = tableDataCoverageHandler.repositoryHandler.children[index];
                if (child.name === this.nodeNoName()) {
                    child.name = `${fieldName}_${child.id}`;
                }
                else {
                    child.name = `${fieldName}_${child.name}`;
                }
            }
        }
    }
    // protected getNodeOnScreen() : GenericResult {
    //     // If we can find ourself without relative to the previous result, great. If not,
    //     // ask our parent to get itself.
    //     // As a body, we are part of the table which is always our parent
    //     // Get the body row
    //     let tableCoverageHandler: TableWebControlCoverageHandler = (<TableWebControlCoverageHandler>this.parentCoverageHandler);
    //     let result: GenericResult = tableCoverageHandler.getSelectedBodyRowOnScreen();
    //     if (!result.success) {
    //         return result;      // We failed to access parents path
    //     }
    //     return result;
    // }
    /**
     * This method creates a selector from this coverage handler to childDomNode
     * @param childDomNode
     * @param useExistingSelector
     * @returns a selector
     */
    createSelectorToChild(childDomNode, useExistingSelector) {
        // Get our JQuery path from this element to the given child node
        let partialSelector = this.createSelectorFromParentToChild(this.domNode, childDomNode);
        // As we will find ourselves, this partial selector is enough
        return partialSelector;
    }
    findColumnNumber(elementDomNode) {
        // Find the index of the element in the list
        let columnNumber = 0;
        this.walkOnChildren(this.domNode, function (node) {
            let span = 1;
            if (node === elementDomNode) {
                return false; // Stop looping
            }
            else {
                if (node.hasAttribute("span")) {
                    span = parseInt(node.getAttribute("span"));
                }
                else if (node.hasAttribute("colspan")) {
                    span = parseInt(node.getAttribute("colspan"));
                }
                columnNumber += span;
                // Continue indication
                return true;
            }
        });
        return columnNumber;
    }
    getColumnName(columnNumber) {
        // We need to go up for the table to execute it.
        let tableCoverageHandler = this.parentCoverageHandler;
        return tableCoverageHandler.getColumnName(columnNumber);
    }
    /**
     * This method decide if to add this control coverage into repository
     * @returns false by default
     */
    isNodeToBeAddedToRepository() {
        return false;
    }
    /**
     * This function needs to be override because this CH is not added to repository, so we only have to continue to parent
     * @param childRepositoryNode
     * @param childCoverageHandler
     * @returns
     */
    addChildRepositoryNodeToOurselvesRecursively(childRepositoryNode, childCoverageHandler) {
        return this.parentCoverageHandler.addChildRepositoryNodeToOurselvesRecursively(childRepositoryNode, childCoverageHandler);
    }
    canAccessDirectly() {
        return true;
    }
    getNode() {
        log.trace(`Inside getNode`);
        return this.returnSuccess({ accessResult: this.$currentNode });
    }
}
exports.default = TableRowWebControlCoverageHandler;
//# sourceMappingURL=TableRowWebControlCoverageHandler.js.map