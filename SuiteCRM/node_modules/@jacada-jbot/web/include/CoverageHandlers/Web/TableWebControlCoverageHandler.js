"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const WebControlCoverageHandler_1 = require("./WebControlCoverageHandler");
const GenericResult_1 = require("@jacada-jbot/base/include/Model/GenericResult");
const $ = require("jquery");
const TableHeaderWebControlCoverageHandler_1 = require("./TableHeaderWebControlCoverageHandler");
const Log4jConfig_1 = require("@jacada-jbot/base/include/Utils/Log4jConfig");
const TableRowWebControlCoverageHandler_1 = require("./TableRowWebControlCoverageHandler");
const TableDataResponse_1 = require("@jacada-jbot/base/include/Model/TableDataResponse");
const WebCustomTableControlCoverageHandler_1 = require("./WebCustomTableControlCoverageHandler");
const Constants_1 = require("@jacada-jbot/base/include/Model/Constants");
const log = Log4jConfig_1.logFactory.getLogger("TableWebControlCoverageHandler");
/*
 * This is a basic table. There are 2 types of tables in Web: One which displays same kind of data row after row and there are tables which are just used as grid.
 * For a grid, we are like a container.
 * For rows Table:
 *  It has columns where all the rows have the same columns structure. Columns might have titles.
 *  Accessing a row is through a 'selected row' which can be acquired using multiple methods
 *
 */
class TableWebControlCoverageHandler extends WebControlCoverageHandler_1.default {
    constructor() {
        super(...arguments);
        this.currentRow = 0;
        this.type = "Table";
        // private getColumnIndex(columnName: string): number {
        //     // Ask the children which is the TableHeader for that (if exists)
        //     if (!this.headerCoverageHandler) return null;
        //     return this.headerCoverageHandler.getColumnIndex(columnName);
        // }
    }
    /**
     * This method gets a list of rows and fields, and returns the corresponding data from the table.
     * @param tableData - the data to get from the table, of type TableDataGetter
     * @returns a GenericResult struct with the required data inside the Data (of the GenericResult)
     */
    getTableDataByRange(tableData) {
        log.trace("Inside getTableDataByRange");
        this.makeRelativePaths(tableData); //TODO: temporary, need to send relative on capture
        this.numberOfTRInBodyRow = this.getNumberOfRows();
        // In case the range is bigger than the number of rows, we want to loop only on the number of existing rows
        const endLoop = tableData.rows.range.to > this.numberOfTRInBodyRow ? this.numberOfTRInBodyRow : tableData.rows.range.to;
        const result = this.walkOnRows(tableData.rows.range.from - 1, endLoop, (row) => {
            return row.executeGetOnRow(tableData.fields);
        });
        return result;
    }
    /**
     * This method gets a list of rows and fields, and returns the corresponding data from the table.
     * @param tableData - the data to get from the table, of type TableDataGetter
     * @returns a GenericResult struct with the required data inside the Data (of the GenericResult)
     */
    getTableDataByField(tableData) {
        log.trace("Inside getTableDataByField");
        tableData.rows.criteria.path = this.makeSingleRelativePath(tableData.rows.criteria.path);
        this.makeRelativePaths(tableData); //TODO: temporary, need to send relative on capture
        this.numberOfTRInBodyRow = this.getNumberOfRows();
        const result = this.walkOnRows(0, this.numberOfTRInBodyRow, (row) => {
            const result = row.checkRowCriteria(tableData.rows.criteria);
            if (result.success && result.data) {
                return row.executeGetOnRow(tableData.fields);
            }
            return result;
        });
        return result;
    }
    /**
     * This method gets a list of rows and fields, and sets the corresponding data on the table.
     * @param {TableDataSetter[]} tableData - the data to set on the table, of type TableDataSetter
     * @return {*}  {GenericResult}
     * @memberof TableWebControlCoverageHandler
     */
    setTableData(tableData) {
        log.trace("Inside setTableData");
        let result;
        for (let i = 0; i < tableData.length; i++) {
            this.makeRelativePaths(tableData[i]); //TODO: temporary, need to send relative on capture
            const rowId = +tableData[i].rowId;
            result = this.walkOnRows(rowId, rowId + 1, (row) => {
                return row.executeSetOnRow(tableData[i].fields);
            });
            if (!result.success)
                return result;
        }
        return result;
    }
    walkOnRows(start, end, func) {
        let dataResponse = [];
        for (let i = start; i < end; i++) {
            this.currentRow = i;
            log.debug(`Getting data for row number: ${this.currentRow}`);
            let result = this.getSelectedBodyRowOnScreen();
            if (!result.success)
                return result;
            const rowNode = result.data.accessResult;
            this.createTableRowCoverageHandler(rowNode);
            result = func(this.rowCoverageHandler);
            if (!result.success)
                return result;
            if (result.data) {
                dataResponse.push(new TableDataResponse_1.default(this.currentRow, result.data));
            }
        }
        return this.returnSuccess(dataResponse);
    }
    /**
     * @temp
     * This method gets tableData which holds absolute paths inside, and turns it into relative paths to the table.
     * @param tableData - the data to change
     */
    makeRelativePaths(tableData) {
        let self = this;
        tableData.fields.forEach((element) => {
            element.path = self.makeSingleRelativePath(element.path);
        });
    }
    makeSingleRelativePath(path) {
        let index = path.indexOf(`${this.repositoryHandler.pathId}/`);
        let length = this.repositoryHandler.pathId.length + index + 1;
        path = path.substring(length);
        return path;
    }
    /**
     * This method gets the number of all rows in the table.
     * @private
     * @return {*}  {number} the number of rows
     * @memberof TableWebControlCoverageHandler
     */
    getNumberOfRows() {
        const rows = this.customCoverageHandler.getTableRows();
        if (!rows)
            return 0;
        return rows.length;
    }
    /**
     * This method gets the node of the current selected row
     * @returns the node of the row
     */
    getSelectedBodyRowOnScreen() {
        log.trace(`In getSelectedBodyRowOnScreen`);
        // Get the selected row
        // Before that, we need to get ourselves.
        if (!this.$currentNode) {
            const result = this.getNodeOnScreen();
            if (!result.success)
                return result; // Cannot get the current node on the screen
        }
        // Getting ourselves as object.
        this.domNode = this.$currentNode[0];
        // We now need to get the rows below the body
        const $trs = this.customCoverageHandler.getTableRows();
        if ($trs.length === 0) {
            return this.returnFailure("No rows in the table");
        }
        if (this.currentRow >= $trs.length) {
            return this.returnFailure("Selected row is out of bound");
        }
        // Return the row
        return this.returnSuccess({ accessResult: $trs.eq(this.currentRow) });
    }
    // private getCurrentLineIndex(): GenericResult {
    //     return this.returnSuccess(this.getSelectedLineIndex(this.repositoryHandler.pathId));
    // }
    // private getSelectedLineIndex(pathId: string): number {
    //     // Should be in memory
    //     let selectedIndex: number = this.applicationData.getScreenTopicData(pathId, this.SELECTED_LINE_INDEX_KEY);
    //     if (!selectedIndex) {
    //         selectedIndex = 0;
    //     }
    //     return selectedIndex;
    // }
    // private setCurrentLineIndex(lineIndex: number): GenericResult {
    //     let nRows = this.getTableNumberOfRows(this.$currentNode);
    //     if (lineIndex < 0 || lineIndex >= nRows) {
    //         return this.returnFailure("Index out of bound");
    //     }
    //     this.setSelectedLineIndex(this.repositoryHandler.pathId, lineIndex);
    //     return this.returnSuccess(false);
    // }
    // private setCurrentLineIndexAsFirst(): GenericResult {
    //     let nRows = this.getTableNumberOfRows(this.$currentNode);
    //     if (nRows == 0) {
    //         return this.returnFailure("Index out of bound");
    //     }
    //     this.setSelectedLineIndex(this.repositoryHandler.pathId, 0);
    //     return this.returnSuccess(false);
    // }
    // private setCurrentLineIndexAsLast(): GenericResult {
    //     let nRows = this.getTableNumberOfRows(this.$currentNode);
    //     if (nRows == 0) {
    //         return this.returnFailure("Index out of bound");
    //     }
    //     this.setSelectedLineIndex(this.repositoryHandler.pathId, nRows - 1);
    //     return this.returnSuccess(false);
    // }
    // private setSelectedLineIndex(pathId: string, lineIndex: number) {
    //     // Set in memory
    //     this.applicationData.setScreenTopicData(pathId, this.SELECTED_LINE_INDEX_KEY, lineIndex);
    // }
    // private getNumberOfRows(): GenericResult {
    //     return this.returnSuccess(this.getTableNumberOfRows(this.$currentNode));
    // }
    // private getTableNumberOfRows($currentNode: JQuery): number {
    //     // We not need to get the rows below the body
    //     let $trs: JQuery = this.getTableRows($currentNode);
    //     return $trs.length;
    // }
    // public executeStartRecordingOnNode(): boolean {
    //     // No user event on table ?
    //     return true;
    // }
    // public performStartRecording(): GenericResult {
    //     if (!this.rowsCoverageHandler) {
    //         this.rowsCoverageHandler = [];
    //     }
    //     this.currentRow = 0;
    //     return super.performStartRecording();
    // }
    // public performStartRecordingOnNode(node: HTMLElement): boolean {
    //     let self = this;
    //     // We can have a few options node: caption, colgroup, thead, tbody, tr, tfoot. Lets handle manually each one of them
    //     let nodeType: string = this.getCoverageHandlerFactory().nodeToNodeType(node).toLowerCase();
    //     if (nodeType === 'thead') {
    //         // Currently we support only one header line
    //         let $trs = $(node).children("tr");
    //         if ($trs.length > 0) {
    //             this.performStartRecordingOnHeaders($trs[0]);
    //         }
    //     } else if (nodeType === 'tbody') {
    //         // Currently we support only one body line for regular table
    //         let $trs = $(node).children("tr");
    //         for (let i = 0; i < $trs.length; i++) {
    //             this.performStartRecordingOnBody(i, $trs[i]);
    //         }
    //     } else if (nodeType === 'tr') {
    //         // In case we already have header and body, just ignore it
    //         if (this.getTableType() === TableWebControlCoverageHandler.TABLE_TYPE_SINGLE_SELECTION && this.numberOfHeaderLines > 0 && this.numberOfTRInBodyLine > 0) return true;
    //         // If there are no tds (only th), and we have no header, it can be a header line
    //         if ($(node).children("th").length > 0 && $(node).children("td").length === 0) {
    //             // Header line. If we already have headers, ignore it. Otherwise go for it.
    //             if (this.getTableType() === TableWebControlCoverageHandler.TABLE_TYPE_SINGLE_SELECTION && this.numberOfHeaderLines > 0) return true;
    //             this.performStartRecordingOnHeaders(node);
    //         } else {
    //             // Body line. We only process the first
    //             if (this.getTableType() === TableWebControlCoverageHandler.TABLE_TYPE_SINGLE_SELECTION && this.numberOfTRInBodyLine > 0) return true;
    //             this.performStartRecordingOnBody(this.currentRow, node);
    //             this.currentRow++;
    //         }
    //     } else if (nodeType === 'tfoot') {
    //     }
    //     // Return code is important to continue the walking on childs
    //     return true;
    // }
    // private performStartRecordingOnHeaders(node: HTMLElement): boolean {
    //     this.numberOfHeaderLines = 1;
    //     // We will have 2 children: TableHeader and TableBody. We need to create the handlers for them if they don't exist
    //     if (!this.headerCoverageHandler) {
    //         let result: GenericResult = this.getCoverageHandlerForControl("TableHeader");
    //         if (!result.success) return false;
    //         this.headerCoverageHandler = result.data.coverageHandler;
    //     }
    //     this.headerCoverageHandler.domNode = node;
    //     // Let the coverage prepare for the recording
    //     this.headerCoverageHandler.performStartRecording();
    //     return true;
    // }
    // private performStartRecordingOnBody(index: number, node: HTMLElement): boolean {
    //     if (!this.numberOfHeaderLines) this.numberOfHeaderLines = 1;
    //     if (index >= this.rowsCoverageHandler.length) {
    //         // Add to the array
    //         let result: GenericResult = this.getCoverageHandlerForControl("WebTableRowControl");
    //         if (!result.success) return false;
    //         this.rowsCoverageHandler.push(result.data.coverageHandler);
    //     } else if (!this.rowsCoverageHandler[index]) {
    //         // Create in the array
    //         let result: GenericResult = this.getCoverageHandlerForControl("WebTableRowControl");
    //         if (!result.success) return false;
    //         this.rowsCoverageHandler[index] = result.data.coverageHandler;
    //     }
    //     this.rowsCoverageHandler[index].domNode = node;
    //     // Let the coverage prepare for the recording
    //     this.rowsCoverageHandler[index].performStartRecording();
    //     return true;
    // }
    performStartRecording() {
        if (this.customCoverageHandler.tableType === WebCustomTableControlCoverageHandler_1.default.TABLE_TYPE_GRID) {
            this.walkOnChildren(this.customCoverageHandler.node[0], (node) => {
                // in walkOnChildren we check that the function returns true otherwise, we don't continue to the next sibling
                return this.performStartRecordingOnNode(node);
            });
        }
        return this.returnSuccess();
    }
    performStartCapturing() {
        if (this.customCoverageHandler.tableType === WebCustomTableControlCoverageHandler_1.default.TABLE_TYPE_GRID) {
            this.walkOnChildren(this.customCoverageHandler.node[0], (node) => {
                return this.performStartCapturingOnNode(node);
            });
        }
        if (!this.customCoverageHandler.isCapturable()) {
            return this.returnSuccess();
        }
        this.fieldsPathIds = [];
        this.createTableHeaderAndRowCoverageHandlers();
        this.registerControlForHighlight(this, this.$currentNode, () => {
            //First, we save the previous repository in case the capture will fail, and we will be able to revert the repository
            // so it won't be corrupted.
            // Then we delete the repository in order to add it from scratch in case there was a change in the table.
            let previousRepository;
            if (!this.repositoryHandler) {
                if (this.applicationCoverageHandler.repositoryHandler) {
                    this.createRepositoryIfNotExists();
                }
            }
            previousRepository = this.repositoryHandler.currentNode;
            if (previousRepository) {
                this.repositoryHandler.parentHandler.removeNodeFromChildren(previousRepository);
            }
            this.repositoryHandler = null;
            try {
                this.rowCoverageHandler.collectFieldsPathIds(this.fieldsPathIds);
                this.validateAndMergeRepository();
                this.reportTreeChanged();
                try {
                    log.debug(`getElementCoordinates`);
                    const elementCoordinates = this.getElementCoordinates();
                    log.debug(`got element coordinates`);
                    log.debug(`createElementSnapshot`);
                    this.createElementSnapshot((snapshot) => {
                        log.debug(`element snapshot created`);
                        try {
                            this.reportCapturedTable(this.fieldsPathIds, snapshot, elementCoordinates);
                        }
                        catch (error) {
                            log.error(`Failed to report captured element`);
                            this.platformDriver.throwException(error, "ReportElementCapturedException");
                        }
                    });
                }
                catch (error) {
                    log.error("cannot create element snapshot");
                    try {
                        // Report JBot about the captured element
                        this.reportCapturedTable(this.fieldsPathIds);
                    }
                    catch (error) {
                        log.error(`Failed to report captured element`);
                        this.platformDriver.throwException(error, "ReportElementCapturedException");
                    }
                }
            }
            catch (error) {
                this.addOrUpdateRepositoryNodes(previousRepository);
                this.platformDriver.throwException(error, "ReportTreeChangedException");
            }
        });
        return this.returnSuccess();
    }
    /**
     * This method executes the action received
     * @param lAction - the action to execute
     * @returns a GenericResult struct
     */
    executingAction(lAction, elementPath) {
        const parsedValue = JSON.parse(lAction.values);
        if (this[lAction.actionName]) {
            return this[lAction.actionName].apply(this, parsedValue);
        }
        else if (this.customCoverageHandler[lAction.actionName]) {
            return this.customCoverageHandler[lAction.actionName].apply(this.customCoverageHandler, parsedValue);
        }
        log.error(`Control coverage handler ${this.repositoryHandler.name} does not implement action ${lAction.actionName}`);
        return new GenericResult_1.GenericResult(false, `Invalid action ${lAction.actionName} on element ${elementPath._elementPathId}`, Constants_1.Constants.TYPE_MISMATCH_EXCEPTION);
    }
    /**
     * This method will add the the given repository node to it's parent in the repository, or updates the existing one.
     * @private
     * @param {*} previousRepositoryNode
     * @memberof TableWebControlCoverageHandler
     */
    addOrUpdateRepositoryNodes(previousRepositoryNode) {
        if (!this.repositoryHandler) {
            this.AddToClosestParentInRepository(previousRepositoryNode);
        }
        else {
            this.repositoryHandler.parentHandler.removeNodeFromChildren(previousRepositoryNode);
            this.AddToClosestParentInRepository(previousRepositoryNode);
        }
    }
    /**
     * This method creates coverageHandler for the rows and header
     */
    createTableHeaderAndRowCoverageHandlers() {
        log.trace(`Inside createTableHeaderAndRowCoverageHandlers`);
        const $rows = this.customCoverageHandler.getTableRows();
        this.createTableRowCoverageHandler($rows[0]);
        const headerRow = this.customCoverageHandler.getTableHeader();
        this.createTableHeaderCoverageHandler(headerRow);
    }
    /**
     * This method gets a headerRow node a creates a coverage handler
     * @param headerRow
     */
    createTableHeaderCoverageHandler(headerRow) {
        log.trace(`Inside createTableHeader`);
        if (!this.headerCoverageHandler) {
            const headerCoverageHandler = new TableHeaderWebControlCoverageHandler_1.default(this.platformDriver, this.repositoryHandler, this.applicationData, this, this.factory, this.applicationCoverageHandler);
            this.headerCoverageHandler = headerCoverageHandler;
        }
        this.headerCoverageHandler.customCoverageHandler = this.customCoverageHandler;
        this.headerCoverageHandler.domNode = headerRow;
        this.headerCoverageHandler.$currentNode = $(headerRow);
    }
    /**
     * This method gets a node of the row, and creates a coverageHandler.
     * @param bodyRow - the node of the row
     */
    createTableRowCoverageHandler(bodyRow) {
        log.trace(`Inside createTableRowCoverageHandler`);
        const rowCoverageHandler = new TableRowWebControlCoverageHandler_1.default(this.platformDriver, this.repositoryHandler, this.applicationData, this, this.factory, this.applicationCoverageHandler);
        this.rowCoverageHandler = rowCoverageHandler;
        this.rowCoverageHandler.customCoverageHandler = this.customCoverageHandler;
        this.rowCoverageHandler.domNode = bodyRow;
        this.rowCoverageHandler.$currentNode = $(bodyRow);
        this.rowCoverageHandler.repositoryHandler = this.repositoryHandler;
    }
    walkOnChildren(parentNode, func) {
        this.numberOfColumns = 0;
        this.numberOfHeaderRows = 0;
        this.numberOfTRInBodyRow = 0;
        super.walkOnChildren(parentNode, func);
    }
    performCapturingOnChildren() {
        // Most of the logic is executed when running on the nodes
        return false;
    }
    /**
     * This method creates a selector from the nodes' parent to the node itself
     * @param childDomNode
     * @param useExistingSelector
     * @returns a selector
     */
    createSelectorToChild(childDomNode, useExistingSelector) {
        // Get our JQuery path from this element to the given child node
        const partialSelector = this.createSelectorFromParentToChild(this.domNode, childDomNode);
        // As we will find ourselves, this partial selector is enough
        return partialSelector;
    }
    createElementRepositoryNode() {
        let repositoryNode = super.createElementRepositoryNode();
        repositoryNode.config.nodeName = this.domNode.nodeName;
        repositoryNode.tableType = this.customCoverageHandler.tableType;
        this.customCoverageHandler.updateElementRepositoryNode(repositoryNode);
        return repositoryNode;
    }
    getName(repositoryNode) {
        let $caption = this.customCoverageHandler.node.children("caption");
        if ($caption.length > 0) {
            let name = $caption.text();
            if (name.length > 0)
                return name;
        }
        return super.getName(repositoryNode);
    }
    getAutoGeneratedIdPrefix() {
        return this.customCoverageHandler.type;
    }
    getColumnName(columnNumber) {
        // Ask the children which is the TableHeader for that (if exists)
        if (!this.headerCoverageHandler)
            return null;
        return this.headerCoverageHandler.getColumnName(columnNumber);
    }
}
exports.default = TableWebControlCoverageHandler;
TableWebControlCoverageHandler.ACTION_SELECT_FIRST = "set_SelectedFirst";
TableWebControlCoverageHandler.ACTION_SELECT_LAST = "set_SelectedLast";
//# sourceMappingURL=TableWebControlCoverageHandler.js.map