import WebControlCoverageHandler from "./WebControlCoverageHandler";
import { GenericResult } from "@jacada-jbot/base/include/Model/GenericResult";
import ExecutionLogicalAction from "@jacada-jbot/base/include/Model/ExecutionLogicalAction";
import ElementPath from "@jacada-jbot/base/include/Model/ElementPath";
import ListeningElement from "@jacada-jbot/base/include/Model/ListeningElement";
import ChromePlatformDriver from "../../PlatformDrivers/ChromePlatformDriver";
import RepositoryHandler from "@jacada-jbot/base/include/Model/RepositoryHandler";
import WebApplicationCoverageHandler from "./WebApplicationCoverageHandler";
import ApplicationData from "@jacada-jbot/base/include/Model/ApplicationData";
import WebCoverageHandlerFactory from "./WebCoverageHandlerFactory";
/**
 * Coverage handler for a iframe
 */
export default class FrameWebControlCoverageHandler extends WebControlCoverageHandler {
    private static readonly FRAME_NOT_SYNC_MESSAGE;
    /**
     * The guid indicating uniquely this element
     */
    private guid;
    static readonly type: string;
    /**
     *
     */
    constructor(platformDriver: ChromePlatformDriver, repositoryHandler: RepositoryHandler, applicationData: ApplicationData, parentCoverageHandler: WebControlCoverageHandler, factory: WebCoverageHandlerFactory, applicationCoverageHandler?: WebApplicationCoverageHandler);
    execLastNodeOnScreenAsync(elementPath: ElementPath, lAction: ExecutionLogicalAction, validateOnly: boolean): Promise<GenericResult>;
    setNode(node: any): void;
    /**
     * This method performs an action on element, In iFrame, we need to dig deep into the child's frame itself and let it run.
     * We will need to wait for this result.
     * Before that, we need to get ourselves, like we are the last.
     * @param elementPath path of DOM element in the repository
     * @param executionLogicalAction action to perform on DOM element
     * @param validateOnly if true do not perform action just validate that element is exists otherwise perform  executionLogicalAction
     * @returns a GenericResult struct
     */
    protected execNextNodeOnScreenAsync(elementPath: ElementPath, executionLogicalAction: ExecutionLogicalAction, validateOnly: boolean): Promise<GenericResult>;
    /**
     * Call ```PlatformDriver``` to perform start listening element on frame
     * @param elementPath path to element we are going to listen
     * @param attributes attribute of element we are going to listen
     * @returns a GenericResult struct
     */
    listenLastNodeOnScreen(elementPath: ElementPath, listeningElement: ListeningElement): GenericResult;
    /**
     * This method registers an event for triggers that will be fired from iFrame's contents
     */
    private registerForFrameTriggeredBelow;
    /**
     * This method registers an event for listening element that will be fired from iFrame's contents
     */
    private registerForFrameListenedBelow;
    performStartRecording(): GenericResult;
    /**
     * This method executes capture on the iFrame's contents elements.
     * @returns false if this iFrame not known to JBot otherwise true
     */
    performStartCapturing(): GenericResult;
    createElementRepositoryNode(): any;
    getName(repositoryNode: any): string;
    getAutoGeneratedIdPrefix(): string;
    /**
     * Register event by event name on element DOM node
     * @param $elem element DOM node
     * @param eventName such as click , change etc.
     * @param func event handler
     * @returns
     */
    private registerEvent;
    /**
     * This method adds a unique id attribute to this iFrame, which let JBot know that this iFrame was already scanned.
     * @returns unique id
     */
    static synchIdToContent(node: HTMLElement): void;
    private static generateGuid;
    /**
     * Event handler for element that been recorded in iFrame's content
     * @param event data of the recorded element
     * @returns
     */
    private frameRecordedBelow;
    /**
     * This method calculates the coordinates of the element inside the iFrame.
     * @param data
     * @returns an array holding the coordinates.
     */
    private CalculateElementCoordinates;
    /**
     * Event handler for element that has been captured in iFrame's content
     * @param event data of which element has been captured
     * @returns
     */
    private frameCapturedBelow;
    /**
     * Event handler for table that been captured in iFrame's content
     */
    private frameCapturedTableBelow;
    private treeChangedBelow;
    /**
     * Find all repository handlers of frame's type
     * @param repositoryHandler current repository handler
     * @param parentRepositoryHandler parent repository handler
     * @param matchedFrameRepositoryHandlers array of frame  repository handlers that matches
     */
    private static findFrameRepositoryHandlers;
    /**
     * Searches sub application in the repository
     * if exists sends a message to background with sub repository
     * otherwise the background will create it for us
     * @param applicationCoverageHandler
     */
    static searchSubApplicationsInRepository(applicationCoverageHandler: WebApplicationCoverageHandler): void;
    /**
     * Send message to inner frame in order to register
     * @param frame The frame to send message to
     * @param subRepository in case sub-application exists pass it other wise we pass null
     */
    private static registerFrame;
    /**
     * This method build a selector from frame repository handlers and goes up until screen repository handler
     * Once we have a selector we are evaluate it and returns what it was found
     * @param frameRepositoryHandler a frame repository handlers
     * @param screenType the type of screen in the repository
     * @returns the result of the evaluation of the selector
     */
    private static findFrameOnScreenBySelector;
}
