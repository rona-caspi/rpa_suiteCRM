"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebCustomControlCoverageHandler = void 0;
const CustomControlCoverageHandler_1 = require("@jacada-jbot/base/include/CoverageHandlers/CustomControlCoverageHandler");
const Log4jConfig_1 = require("@jacada-jbot/base/include/Utils/Log4jConfig");
const Constants_1 = require("../../Model/Constants");
const GenericResult_1 = require("@jacada-jbot/base/include/Model/GenericResult");
const log = Log4jConfig_1.logFactory.getLogger("WebCustomControlCoverageHandler");
class WebCustomControlCoverageHandler extends CustomControlCoverageHandler_1.CustomControlCoverageHandler {
    /**
     *
     */
    constructor(node, recordingStepReporter, listeningReporter) {
        super(node, recordingStepReporter, listeningReporter);
        this.recordingStepReporter = recordingStepReporter;
        this.listeningReporter = listeningReporter;
        this.node = $(node);
        this.node.data(Constants_1.Constants.JBOT_UNIQUE_ID_KEY, this.node.getUniqueId());
    }
    recordEvent(eventName, callback) {
        const uniqueId = this.node.data(Constants_1.Constants.JBOT_UNIQUE_ID_KEY);
        this.node.onNative(eventName, uniqueId, (event) => {
            const logicalAction = callback(event);
            this.recordingStepReporter(logicalAction);
        });
        this.node.attr(Constants_1.Constants.JBOT_REGISTERED_ATTR, "");
    }
    /**
     * Registers to overlayClicked event during the recording process.
     * The event will be fired when a user performs a mouse click on top of the element, preventing default action from occurring.
     * @param callback function that will be called whenever the specified event is delivered to the target
     * @param postRecordEventCallback  function that will be called right after we update JBot with callback result, coverage writer should perform the original action ( click / set text )
     */
    recordOverlayClickedEvent(callback, postRecordEventCallback) {
        log.trace(`Register ${Constants_1.Constants.EVENT_OVERLAY_CLICKED} event for recording`);
        this.node.data(Constants_1.Constants.IS_PREVENT_CLICK_ON_ELEMENT, true);
        const uniqueId = this.node.data(Constants_1.Constants.JBOT_UNIQUE_ID_KEY);
        this.node.onNative(Constants_1.Constants.EVENT_OVERLAY_CLICKED, uniqueId, async (event) => {
            let logicalAction = null;
            try {
                //callback can throw an exception (written by coverage writer)
                logicalAction = callback(event);
            }
            catch (error) {
                log.error(`Could not perform callback function of type ${this.type}`);
                //TODO: Error handling
                throw error;
            }
            if (!logicalAction) {
                log.debug(`logicalAction returned is null: ${this.type}`);
                return;
            }
            log.debug(`logicalAction returned is ${logicalAction.actionName}`);
            await this.recordingStepReporter(logicalAction);
            log.debug(`Sending recorded step completed for ${this.type} action ${logicalAction.actionName}`);
            try {
                //postRecordEventCallback can throw an exception (written by coverage writer)
                postRecordEventCallback(event);
            }
            catch (error) {
                //TODO: Error handling
                log.error(`Could not perform postRecordEventCallback function of type ${this.type}`);
                throw error;
            }
        });
        this.node.attr(Constants_1.Constants.JBOT_REGISTERED_ATTR, "");
    }
    listenToEvent(eventName, callback) {
        const uniqueId = this.node.data(Constants_1.Constants.JBOT_UNIQUE_ID_KEY);
        this.node.onNative(eventName, uniqueId, (event) => {
            const eventDetails = callback(event);
            this.listeningReporter(eventDetails.newValue, eventDetails.name);
        });
        this.node.attr(Constants_1.Constants.JBOT_REGISTERED_ATTR, "");
    }
    subscribeToExistsChanged() {
        this.node.off("nodeAdded");
        this.node.on("nodeAdded", () => {
            this.listeningReporter(true, "existsChanged");
        });
        this.node.off("nodeRemoved");
        this.node.on("nodeRemoved", () => {
            this.listeningReporter(false, "existsChanged");
        });
    }
    subsribeToDisabledChanged() {
        this.node.off("attributeChanged");
        this.node.on("attributeChanged", (_e, attributeName) => {
            if (attributeName === "disabled") {
                const isDisabled = this.node.prop("disabled");
                this.listeningReporter(isDisabled, "disabledChanged");
            }
        });
    }
    /**
     * Getter of attribute isExits
     * @returns true - always
     */
    isExists() {
        const nodeExists = $(document).find(this.node).length > 0;
        return new GenericResult_1.GenericResult(true, null, nodeExists);
    }
    /**
     * Getter of attribute isDisabled
     * @returns true if the node is disabled, false otherwise
     */
    isDisabled() {
        let isDisabled = this.node.prop("disabled");
        return new GenericResult_1.GenericResult(true, null, isDisabled);
    }
}
exports.WebCustomControlCoverageHandler = WebCustomControlCoverageHandler;
//# sourceMappingURL=WebCustomControlCoverageHandler.js.map