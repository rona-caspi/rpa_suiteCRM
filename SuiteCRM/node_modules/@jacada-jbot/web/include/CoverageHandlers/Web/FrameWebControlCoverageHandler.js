"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const WebControlCoverageHandler_1 = require("./WebControlCoverageHandler");
const GenericResult_1 = require("@jacada-jbot/base/include/Model/GenericResult");
const LogicalAction_1 = require("@jacada-jbot/base/include/Model/LogicalAction");
const $ = require("jquery");
const Log4jConfig_1 = require("@jacada-jbot/base/include/Utils/Log4jConfig");
const ChromePlatformDriver_1 = require("../../PlatformDrivers/ChromePlatformDriver");
const Constants_1 = require("../../Model/Constants");
const RepositoryHandler_1 = require("@jacada-jbot/base/include/Model/RepositoryHandler");
const log = Log4jConfig_1.logFactory.getLogger("FrameWebControlCoverageHandler");
/**
 * Coverage handler for a iframe
 */
class FrameWebControlCoverageHandler extends WebControlCoverageHandler_1.default {
    /**
     *
     */
    constructor(platformDriver, repositoryHandler, applicationData, parentCoverageHandler, factory, applicationCoverageHandler) {
        super(platformDriver, repositoryHandler, applicationData, parentCoverageHandler, factory, applicationCoverageHandler);
        chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
            log.info(`Frame received: ${request.message}`);
            log.debug(`Request is: ${JSON.stringify(request)}`);
            if (request.message === "startListening") {
                this.registerForFrameListenedBelow();
                this.registerForFrameTriggeredBelow();
            }
        });
    }
    async execLastNodeOnScreenAsync(elementPath, lAction, validateOnly) {
        // If we reach the last one (the one needs actions on) go and execute. Otherwise, go deeper.
        // We are the element needed to execute on.
        // Lets get the element.
        let result = this.getNodeOnScreen();
        if (!result.success)
            return new GenericResult_1.GenericResult(false, `Could not find element ${elementPath._elementPathId}`, Constants_1.BaseConstants.ELEMENT_NOT_FOUND_EXCEPTION);
        // Need to execute on the element itself. We are also the coverage handler that knows the control
        let currentNode = result.data.accessResult;
        //save current node on its coverage handler
        this.setNode(currentNode);
        // Go deeper on the path: Continue to next node
        return this.execNextNodeOnScreenAsync(elementPath, lAction, validateOnly);
    }
    setNode(node) {
        log.trace(`Inside setNode`);
        this.domNode = node;
        this.$currentNode = $(node);
        this.guid = this.$currentNode.attr(Constants_1.Constants.ATTR_FRAME_GUID);
        this.$currentNode.data(Constants_1.Constants.JBOT_UNIQUE_ID_KEY, this.$currentNode.getUniqueId());
    }
    /**
     * This method performs an action on element, In iFrame, we need to dig deep into the child's frame itself and let it run.
     * We will need to wait for this result.
     * Before that, we need to get ourselves, like we are the last.
     * @param elementPath path of DOM element in the repository
     * @param executionLogicalAction action to perform on DOM element
     * @param validateOnly if true do not perform action just validate that element is exists otherwise perform  executionLogicalAction
     * @returns a GenericResult struct
     */
    async execNextNodeOnScreenAsync(elementPath, executionLogicalAction, validateOnly) {
        if (!this.guid) {
            return this.returnFailure(FrameWebControlCoverageHandler.FRAME_NOT_SYNC_MESSAGE);
        }
        // Need to get the part of pathId from here down.
        let restOfPathId = elementPath.restPathId();
        return new Promise((resolve, reject) => {
            this.registerEvent(ChromePlatformDriver_1.default.FRAME_EXEC_NODE_ON_SCREEN_COMPLETED_MESSAGE, (event) => {
                const uniqueId = this.$currentNode.data(Constants_1.Constants.JBOT_UNIQUE_ID_KEY);
                this.$currentNode.offNative(ChromePlatformDriver_1.default.FRAME_EXEC_NODE_ON_SCREEN_COMPLETED_MESSAGE, uniqueId);
                var data = event.detail;
                log.debug(`Completed execution. Data is:${JSON.stringify(data)}`);
                // A frame below us finished execution, We now need to return the result
                let frameGuidCompleted = data.frameGuid;
                // Handle only if it's for current instance
                if (frameGuidCompleted === this.guid) {
                    resolve(data.result);
                }
                else {
                    log.trace(`Received an execution result from frame (${frameGuidCompleted}) which is not the same as current instance of frame (${this.guid})`);
                    let gResult = new GenericResult_1.GenericResult(false, "Frame completed by the incorrect frame control coverage", null);
                    reject(gResult);
                }
            });
            // Send message
            // Tell Platform Driver to execute action on the frame
            this.platformDriver.execNextNodeOnScreenOnFrame(this.guid, restOfPathId, executionLogicalAction, validateOnly);
        });
    }
    /**
     * Call ```PlatformDriver``` to perform start listening element on frame
     * @param elementPath path to element we are going to listen
     * @param attributes attribute of element we are going to listen
     * @returns a GenericResult struct
     */
    listenLastNodeOnScreen(elementPath, listeningElement) {
        const result = this.getNodeOnScreen();
        let currentNode;
        //TODO:Error handling for listening
        if (result.success) {
            currentNode = result.data.accessResult;
        }
        //save current node on its coverage handler
        this.setNode(currentNode);
        // Need to get the part of pathId from here down.
        let restOfPathId = elementPath.restPathId();
        if (!this.guid) {
            return this.returnFailure(FrameWebControlCoverageHandler.FRAME_NOT_SYNC_MESSAGE);
        }
        // Ask platform driver to start listening on the frame
        let listeningInfo = { path: restOfPathId, attributes: listeningElement.attributes, triggers: listeningElement.triggers };
        this.platformDriver.startListeningOnFrame(this.guid, listeningInfo);
        return this.returnSuccess(false);
    }
    /**
     * This method registers an event for triggers that will be fired from iFrame's contents
     */
    registerForFrameTriggeredBelow() {
        this.registerEvent(ChromePlatformDriver_1.default.FRAME_TRIGGER_FIRED_MESSAGE, (event) => {
            const data = event.detail;
            log.trace(`Continue to build trigger path. Data is:${JSON.stringify(data)}`);
            // We need to concatenate the paths of what we have now with the one of the iFrame
            const pathId = data.pathId;
            const fullPathId = this.repositoryHandler.mergePaths(this.repositoryHandler.pathId, pathId);
            this.reportTriggerFired(fullPathId, data.trigger);
        });
    }
    /**
     * This method registers an event for listening element that will be fired from iFrame's contents
     */
    registerForFrameListenedBelow() {
        this.registerEvent(ChromePlatformDriver_1.default.FRAME_LISTENED_ELEMENT_MESSAGE, (event) => {
            const data = event.detail;
            log.trace(`Continue to build listening path. Data is:${JSON.stringify(data)}`);
            // We need to concatenate the paths of what we have now with the one of the iFrame
            const pathId = data.pathId;
            const fullPathId = this.repositoryHandler.mergePaths(this.repositoryHandler.pathId, pathId);
            this.platformDriver.reportChangedElement(fullPathId, data.attribute, data.newValue);
        });
    }
    performStartRecording() {
        if (!this.guid) {
            return this.returnFailure(FrameWebControlCoverageHandler.FRAME_NOT_SYNC_MESSAGE);
        }
        // Registering for message on recording on element in the frame below
        this.registerEvent(ChromePlatformDriver_1.default.FRAME_RECORDED_ELEMENT_MESSAGE, this.frameRecordedBelow.bind(this));
        this.registerEvent(ChromePlatformDriver_1.default.FRAME_TREE_CHANGED_MESSAGE, this.treeChangedBelow.bind(this));
        // Ask platform driver to start recording on the frame
        this.platformDriver.startRecordingOnFrame(this.guid);
        return this.returnSuccess();
    }
    /**
     * This method executes capture on the iFrame's contents elements.
     * @returns false if this iFrame not known to JBot otherwise true
     */
    performStartCapturing() {
        if (!this.guid) {
            return this.returnFailure(FrameWebControlCoverageHandler.FRAME_NOT_SYNC_MESSAGE);
        }
        this.registerControlForHighlight(this, this.$currentNode, (event) => {
            this.executeStartCapturingClicked(event);
        });
        // Registering for message on capture on element in the frame below
        this.registerEvent(ChromePlatformDriver_1.default.FRAME_CAPTURED_ELEMENT_MESSAGE, this.frameCapturedBelow.bind(this));
        this.registerEvent(ChromePlatformDriver_1.default.FRAME_CAPTURED_TABLE_MESSAGE, this.frameCapturedTableBelow.bind(this));
        this.registerEvent(ChromePlatformDriver_1.default.FRAME_TREE_CHANGED_MESSAGE, this.treeChangedBelow.bind(this));
        // Ask platform driver to start capture on the frame
        this.platformDriver.startCaptureOnFrame(this.guid);
        return this.returnSuccess();
    }
    createElementRepositoryNode() {
        let repositoryNode = {
            children: [],
            config: {},
            type: FrameWebControlCoverageHandler.type,
        };
        repositoryNode.config.fields = [];
        if (this.$currentNode.attr("id")) {
            // By default the name is the id
            repositoryNode.id = this.cleanId(this.$currentNode.attr("id"));
            repositoryNode.name = this.getName(repositoryNode);
        }
        else {
            repositoryNode.id = Constants_1.BaseConstants.AUTO_GENERATE_ID_PREFIX; // Will be updated once attached to base
            repositoryNode.name = this.getName(repositoryNode);
        }
        const field = { selector: this.createRepositoryNodeSelector(this.domNode) };
        repositoryNode.config.fields.push(field);
        return repositoryNode;
    }
    getName(repositoryNode) {
        if (repositoryNode.id) {
            return repositoryNode.id;
        }
        else {
            return FrameWebControlCoverageHandler.type;
        }
    }
    getAutoGeneratedIdPrefix() {
        return FrameWebControlCoverageHandler.type;
    }
    /**
     * Register event by event name on element DOM node
     * @param $elem element DOM node
     * @param eventName such as click , change etc.
     * @param func event handler
     * @returns
     */
    registerEvent(eventName, func) {
        const uniqueId = this.$currentNode.data(Constants_1.Constants.JBOT_UNIQUE_ID_KEY);
        // Registered already on this element. Let's check if it's for the same event
        if (this.$currentNode.hasNative(eventName, uniqueId)) {
            return;
        }
        this.$currentNode.onNative(eventName, uniqueId, func);
        this.$currentNode.attr(Constants_1.Constants.JBOT_REGISTERED_ATTR, "");
        log.trace(`Register event ${eventName} with id ${uniqueId}`);
    }
    /**
     * This method adds a unique id attribute to this iFrame, which let JBot know that this iFrame was already scanned.
     * @returns unique id
     */
    static synchIdToContent(node) {
        if (node.hasAttribute(Constants_1.Constants.ATTR_FRAME_GUID)) {
            return;
        }
        const guid = this.generateGuid();
        node.setAttribute(Constants_1.Constants.ATTR_FRAME_GUID, guid);
        log.debug(`Created guid:${guid}`);
    }
    static generateGuid() {
        // cSpell:disable
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
            //cSpell:enable
            var r = (Math.random() * 16) | 0, v = c == "x" ? r : (r & 0x3) | 0x8;
            return v.toString(16);
        });
    }
    /**
     * Event handler for element that been recorded in iFrame's content
     * @param event data of the recorded element
     * @returns
     */
    frameRecordedBelow(event) {
        var data = event.detail;
        log.trace(`Continue to build recording path. Data is:${JSON.stringify(data)}`);
        // A frame below us finished capturing, We now need to continue from the iFrame object with this id
        let frameGuidRecorded = data.frameGuid;
        // Handle only if it's for current instance
        if (frameGuidRecorded === this.guid) {
            this.validateAndMergeRepository();
            // We need to concatenate the paths of what we have now with the one of the iFrame
            let pathId = data.pathId;
            let lAction = LogicalAction_1.default.fromJSON(data.logicalAction);
            let fullPathId = this.repositoryHandler.mergePaths(this.repositoryHandler.pathId, pathId);
            //element width and height remain the same, just update values of left and top
            let elementCoordinates = this.CalculateElementCoordinates(data);
            this.platformDriver.reportRecordedStep(lAction, fullPathId, data.snapshot, elementCoordinates);
            return false; // Stop other events
        }
        else {
            log.trace(`Received a recorded element from frame (${frameGuidRecorded}) which is not the same as current instance of frame (${this.guid})`);
        }
    }
    /**
     * This method calculates the coordinates of the element inside the iFrame.
     * @param data
     * @returns an array holding the coordinates.
     */
    CalculateElementCoordinates(data) {
        let elementCoordinates = data.coordinates;
        let iframeCoordinates = this.getElementCoordinates();
        //update left
        elementCoordinates[0] = data.coordinates[0] + iframeCoordinates[0];
        //update top
        elementCoordinates[1] = data.coordinates[1] + iframeCoordinates[1];
        return elementCoordinates;
    }
    /**
     * Event handler for element that has been captured in iFrame's content
     * @param event data of which element has been captured
     * @returns
     */
    frameCapturedBelow(event) {
        const data = event.detail;
        log.debug(`Continue to build capture path. Data is:${JSON.stringify(data)}`);
        this.validateAndMergeRepository();
        // Inform platform driver about it.
        this.reportTreeChanged();
        // We need to concatenate the paths of what we have now with the one of the iFrame
        const pathId = data.pathId;
        const fullPathId = this.repositoryHandler.mergePaths(this.repositoryHandler.pathId, pathId);
        //element width and height remain the same, just update values of left and top
        const elementCoordinates = this.CalculateElementCoordinates(data);
        this.platformDriver.reportCapturedElement(fullPathId, data.snapshot, elementCoordinates);
    }
    /**
     * Event handler for table that been captured in iFrame's content
     */
    frameCapturedTableBelow(event) {
        const data = event.detail;
        log.debug(`Continue to build capture path. Data is:${JSON.stringify(data)}`);
        this.validateAndMergeRepository();
        // Inform platform driver about it.
        this.reportTreeChanged();
        // We need to concatenate the paths of what we have now with the one of the iFrame
        const pathId = data.pathId;
        const fullPathId = this.repositoryHandler.mergePaths(this.repositoryHandler.pathId, pathId);
        const fullFieldsPathIds = [];
        for (let index = 0; index < data.fieldsPathIds.length; index++) {
            const element = data.fieldsPathIds[index];
            fullFieldsPathIds.push(this.repositoryHandler.mergePaths(this.repositoryHandler.pathId, element));
        }
        //element width and height remain the same, just update values of left and top
        const elementCoordinates = this.CalculateElementCoordinates(data);
        this.platformDriver.reportCapturedTable(fullPathId, fullFieldsPathIds, data.snapshot, elementCoordinates);
    }
    treeChangedBelow(event) {
        var data = event.detail;
        log.trace(`iFrame continue to build capture path. Data is:${JSON.stringify(data)}`);
        this.validateAndMergeRepository();
        //We are override the application coverage handler on each change
        if (this.repositoryHandler.children.length > 0) {
            this.repositoryHandler.children[0] = data.applicationHandlerNode;
        }
        else {
            this.repositoryHandler.children.push(data.applicationHandlerNode);
        }
        // Inform platform driver about it.
        this.reportTreeChanged();
    }
    /**
     * Find all repository handlers of frame's type
     * @param repositoryHandler current repository handler
     * @param parentRepositoryHandler parent repository handler
     * @param matchedFrameRepositoryHandlers array of frame  repository handlers that matches
     */
    static findFrameRepositoryHandlers(repositoryHandler, parentRepositoryHandler, matchedFrameRepositoryHandlers) {
        if (repositoryHandler.type == FrameWebControlCoverageHandler.type) {
            const frameRepositoryHandler = new RepositoryHandler_1.default(repositoryHandler.repository, repositoryHandler.currentNode, parentRepositoryHandler);
            matchedFrameRepositoryHandlers.push(frameRepositoryHandler);
        }
        else {
            for (let child of repositoryHandler.children) {
                const childRepositoryHandler = new RepositoryHandler_1.default(repositoryHandler.repository, child, repositoryHandler);
                FrameWebControlCoverageHandler.findFrameRepositoryHandlers(childRepositoryHandler, repositoryHandler, matchedFrameRepositoryHandlers);
            }
        }
    }
    /**
     * Searches sub application in the repository
     * if exists sends a message to background with sub repository
     * otherwise the background will create it for us
     * @param applicationCoverageHandler
     */
    static searchSubApplicationsInRepository(applicationCoverageHandler) {
        const webFrameRepositoryHandlers = [];
        const matchedFrames = [];
        const screenCoverageHandler = applicationCoverageHandler.getDefaultScreenCoverageHandlerForCurrent();
        const screenId = screenCoverageHandler.uniqueId;
        const screenElement = applicationCoverageHandler.repositoryHandler.findElementByIdInCurrent(screenId);
        if (screenElement) {
            const screenRepositoryHandler = new RepositoryHandler_1.default(applicationCoverageHandler.repositoryHandler.repository, screenElement, applicationCoverageHandler.repositoryHandler);
            screenCoverageHandler.repositoryHandler = screenRepositoryHandler;
            FrameWebControlCoverageHandler.findFrameRepositoryHandlers(screenCoverageHandler.repositoryHandler, null, webFrameRepositoryHandlers);
            // checking if there is no children in case we are using empty repository
            for (let frameRepositoryHandler of webFrameRepositoryHandlers) {
                const frameOnScreen = this.findFrameOnScreenBySelector(frameRepositoryHandler, screenCoverageHandler.repositoryHandler.type);
                if (frameOnScreen.length == 0)
                    continue;
                matchedFrames.push(frameOnScreen[0]);
                //reminder:we added frame repository as a first children on tree changed in frame
                //see FrameWebControlCoverageHandler
                // Notify the frame about it so we can sync
                const subRepository = frameRepositoryHandler.children[0];
                this.registerFrame(frameOnScreen[0], subRepository);
            }
        }
        const unmatchedFrames = $("iframe,frame").filter((_index, frame) => {
            return !matchedFrames.includes(frame);
        });
        unmatchedFrames.each((_index, iFrame) => {
            //frame doesn't exist in repository send post message without repository
            //that will create an empty repository if its application matched
            this.registerFrame(iFrame);
        });
    }
    /**
     * Send message to inner frame in order to register
     * @param frame The frame to send message to
     * @param subRepository in case sub-application exists pass it other wise we pass null
     */
    static registerFrame(frame, subRepository) {
        const guid = frame.getAttribute(Constants_1.Constants.ATTR_FRAME_GUID);
        log.debug(`Frame: Notify frame on guid:${guid}`);
        frame.contentWindow.postMessage({
            message: "registerFrame",
            frameGuid: guid,
            repository: subRepository,
        }, "*");
    }
    /**
     * This method build a selector from frame repository handlers and goes up until screen repository handler
     * Once we have a selector we are evaluate it and returns what it was found
     * @param frameRepositoryHandler a frame repository handlers
     * @param screenType the type of screen in the repository
     * @returns the result of the evaluation of the selector
     */
    static findFrameOnScreenBySelector(frameRepositoryHandler, screenType) {
        let currentNode = frameRepositoryHandler;
        let frameSelector = currentNode.config.fields[0].selector;
        while (currentNode.type != screenType) {
            currentNode = currentNode.parentHandler;
            const selectorWithChildren = currentNode.config.fields[0].selector.concat(".children");
            frameSelector = selectorWithChildren.concat(frameSelector);
        }
        const frameOnScreen = eval(frameSelector);
        return frameOnScreen;
    }
}
exports.default = FrameWebControlCoverageHandler;
FrameWebControlCoverageHandler.FRAME_NOT_SYNC_MESSAGE = "This frame is not synced yet";
FrameWebControlCoverageHandler.type = "Frame";
//# sourceMappingURL=FrameWebControlCoverageHandler.js.map