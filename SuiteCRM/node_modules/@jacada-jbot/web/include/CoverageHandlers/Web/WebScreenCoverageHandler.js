"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ScreenCoverageHandler_1 = require("@jacada-jbot/base/include/CoverageHandlers/ScreenCoverageHandler");
const WebControlCoverageHandler_1 = require("./WebControlCoverageHandler");
const ControlCoverageHandler_1 = require("@jacada-jbot/base/include/CoverageHandlers/ControlCoverageHandler");
const WebHighlight_1 = require("../../Utils/WebHighlight");
const WebHighlightElementData_1 = require("../../Model/WebHighlightElementData");
const Log4jConfig_1 = require("@jacada-jbot/base/include/Utils/Log4jConfig");
const ChromePlatformDriver_1 = require("../../PlatformDrivers/ChromePlatformDriver");
const $ = require("jquery");
const _ = require("underscore");
const Constants_1 = require("../../Model/Constants");
const TypeGuards_1 = require("../../Utils/TypeGuards");
const log = Log4jConfig_1.logFactory.getLogger("WebScreenCoverageHandler");
/**
 * Coverage handler for screen
 */
class WebScreenCoverageHandler extends ScreenCoverageHandler_1.default {
    constructor(platformDriver, repositoryHandler, applicationData, parentCoverageHandler, factory, applicationCoverageHandler) {
        super(platformDriver, repositoryHandler, applicationData, parentCoverageHandler, factory, applicationCoverageHandler);
        /**
         * True in case we have started capturing
         *  */
        this.inCaptureMode = false;
        /**
         * Postpone mutation observer callback execution until after wait milliseconds have elapsed since the last time it was invoked.
         */
        this.waitTimeBeforeDetactChanges = 1000;
        this.loadAppSection();
        this.uniqueId = window.location.href.replace(/\W/g, "");
    }
    type() {
        return "WebPage";
    }
    screenChanged() {
        // GD: This method will be called when we will add logical screens (soon)
        this.loadAppSection();
    }
    /**
     * Loading the app sections of this screen
     */
    loadAppSection() {
        this.appSections = this.createAppSections();
    }
    /**
     * Creates the app sections of this screen. Coverage handler with app sections need to inherit this method and create the app sections
     */
    createAppSections() {
        return []; // By default there are no app sections.
    }
    /**
     * The path might be to the app section, not just to this screen so groupNavbar or header is valid.
     * If we have app sections, lets handle them
     * @returns
     */
    validateScreen() {
        for (let i = 0; i < this.appSections.length; i++) {
            let appSection = this.appSections[i];
            // If it's validated (found) we can return
            let result = appSection.validateAppSection(this.repositoryHandler);
            if (result.success) {
                return result;
            }
        }
        return super.validateScreen();
    }
    /**
     *  On a default web screen, which is HTML based, each element decides what to record.
     *  Here we walk on the dom and each element we decide if to listen to it, and listen to it's children.
     * @returns
     */
    startRecording() {
        // Initiating the control mapping
        this.highlightMap = {};
        // Recording on current screen and children
        this.performStartRecording();
        // In case screen changes, we need to re-record
        this.startRecordingChangesOnScreen();
        // Start highlight for recording
        this.startHighlightingOnScreen();
        log.info("Recording was set");
        return this.returnSuccess("");
    }
    stopRecording() {
        this.removeHighlighter();
        this.stopHighlightElementsInScreen();
        this.stopHighlightOnScreen();
        this.stopRecordingChangesOnScreen();
        this.stopRecordingOnFrames();
        this.removeAllRegisteredEvents();
        this.removeAllCoverageHandlersFromNode();
        this.highlightMap = {};
        log.debug("Recording stopped");
        return this.returnSuccess("Recording stopped");
    }
    stopRecordingOnFrames() {
        let $frames = $("iframe,frame");
        $($frames).each((_index, iframe) => {
            let frameGuid = iframe.getAttribute(Constants_1.Constants.ATTR_FRAME_GUID);
            iframe.contentWindow.postMessage({
                message: "stopRecordingOnFrame",
                frameGuid: frameGuid,
            }, "*");
        });
    }
    /**
     *  Remove all elements with Registered Attr.
     */
    removeAllRegisteredEvents() {
        let $registeredElements = $("[" + Constants_1.Constants.JBOT_REGISTERED_ATTR + "]");
        $registeredElements.each((_index, element) => {
            this.removeRegisteredEvent($(element));
        });
        $registeredElements.removeAttr(Constants_1.Constants.JBOT_REGISTERED_ATTR);
    }
    /**
     *  Remove element with Registered Attr.
     */
    removeRegisteredEvent($elem) {
        const uniqueId = $elem.data(Constants_1.Constants.JBOT_UNIQUE_ID_KEY);
        if (uniqueId) {
            $elem.offNativeById(uniqueId);
        }
    }
    /**
     * Remove all registered coverage handlers by JBOT_COVERAGE_HANDLER_UNIQUE_ID_ATTR attribute
     */
    removeAllCoverageHandlersFromNode() {
        let $registeredElements = $("[" + Constants_1.Constants.JBOT_COVERAGE_HANDLER_ATTR + "]");
        $registeredElements.each((_index, element) => {
            this.removeCoverageHandlerFromNode(element);
        });
    }
    performStartRecording() {
        // If we have app sections, lets handle them
        if (this.appSections.length == 0) {
            this.walkOnChildren(document.body, (node) => {
                return this.performStartRecordingOnNode(node);
            });
            return this.returnSuccess("");
        }
        else {
            // Perform the recording on the app sections and then on the main section if exists
            for (let i = 0; i < this.appSections.length; i++) {
                let appSection = this.appSections[i];
                if (appSection.isAppSectionAppear()) {
                    appSection.performStartRecording();
                }
            }
            let $mainSection = this.getMainSection();
            if ($mainSection) {
                this.performStartRecordingOnNode($mainSection[0]);
            }
            return this.returnSuccess("");
        }
    }
    performStartRecordingOnNode(node) {
        // Prepare node for recording. Need to find the coverage handler for this node to execute it.
        // Let the coverage prepare for the recording
        let coverageHandler = this.getCoverageHandlerForNode(node);
        if (coverageHandler instanceof WebControlCoverageHandler_1.default) {
            coverageHandler.performStartRecording();
        }
        else if (coverageHandler instanceof WebScreenCoverageHandler) {
            coverageHandler.walkOnChildren(node, (childNode) => {
                return coverageHandler.performStartRecordingOnNode(childNode);
            });
        }
        else {
            if (coverageHandler) {
                log.error(`Coverage handler of ${node.nodeName} is not inheriting known classes`);
            }
        }
        // Return code is important to continue the walking on children
        return true;
    }
    /**
     * Returns the main section of a screen with app sections. This typically will not be the body therefore it needs to be inherited
     */
    getMainSection() {
        return $("body");
    }
    /**
     * Stops listening on changes on screen (mutation observer)
     */
    stopRecordingChangesOnScreen() {
        if (this.mutationObserver) {
            this.mutationObserver.disconnect();
            this.mutationObserver = null;
        }
    }
    /**
     * Starts listening on changes on screen (mutation observer)
     */
    startRecordingChangesOnScreen() {
        // Save the current screen unique id in order to compare later if we have changed screen
        this.lastUniqueId = this.uniqueId;
        this.mutationObserver = new MutationObserver((mutations) => {
            // Are we in a new logical screen?
            if (this.lastUniqueId != this.uniqueId) {
                log.debug(`Screen was changed to: ${this.uniqueId}`);
                // New screen. Need to stop current recording, notify that it's a new screen and then restart recording
                this.applicationCoverageHandler.stopRecording();
                this.applicationCoverageHandler.startRecording();
                return;
            }
            log.debug(`Processing mutation changes on : ${this.lastUniqueId}`);
            // Loop on all controls changed in screen
            for (const mutation of mutations) {
                for (const node of mutation.addedNodes) {
                    if (!(node instanceof HTMLElement) || node.className === "jBotHighlighter")
                        continue; // not an element
                    // Going up to first coverage handler to start recording from there all the path down
                    this.startRecordingFromFirstParentWithCoverageHandler(node);
                    // Going down in case node is not a leaf and start recording on its children
                    this.walkOnChildren(node, (childNode) => {
                        return this.performStartRecordingOnNode(childNode);
                    });
                }
                for (const node of mutation.removedNodes) {
                    let $element = $(node);
                    // Remove highlight with the mapping
                    let uniqueId = $element.attr(Constants_1.Constants.JBOT_HIGHLIGHT_ATTR_ID);
                    if (uniqueId) {
                        delete this.highlightMap[uniqueId];
                    }
                    this.removeRegisteredEvent($element);
                }
            }
        });
        let mutationsOptions = { subtree: true, childList: true };
        this.mutationObserver.observe(document.body, mutationsOptions);
    }
    /**
     * This method gets a  node, and iterates on it's parents until we find an element with Coverage Handler.
     * Then it start recording down from it
     * @param node
     */
    startRecordingFromFirstParentWithCoverageHandler(node) {
        let coverageHandler = null;
        let nodesStack = [];
        // Iterate on html elements up until we reach and element with coverage handler
        const data = { node, nodesStack, coverageHandler };
        this.findAncestorsCoverageHandler(data);
        // Recording on the stack from top to bottom
        data.coverageHandler.performStartRecordingOnNodesStack(nodesStack);
    }
    /**
     * Populate node stack with nodes start from node until ancestor coverage handler was found
     * @param data
     */
    findAncestorsCoverageHandler(data) {
        while (data.node && !data.node.isEqualNode(document.body)) {
            // Do we have coverage handler for the node ?
            data.coverageHandler = this.fetchCoverageHandlerFromNode(data.node);
            if (data.coverageHandler)
                break;
            // Save the node in a stack as it doesn't have coverage handler and need to be processed.
            data.nodesStack.push(data.node);
            // Node has no coverage handler. Move up in the chain.
            data.node = data.node.parentElement;
        }
        log.debug(`findAncestorsCoverageHandler: ${data.nodesStack.length} . Found coverage ${data.coverageHandler}`);
        if (!data.node) {
            log.debug("DEBUG: Scenario where parent was not body!");
        }
        // If not found, we are (as the screen), are the handler
        if (!data.coverageHandler) {
            data.coverageHandler = this;
        }
    }
    /**
     * This method gets a  node, and iterates on it's parents until we find an element with Coverage Handler.
     * Then it start listening down from it
     * @param node
     */
    startListeningFromFirstParentWithCoverageHandler(node) {
        let coverageHandler = null;
        let nodesStack = [];
        const data = { node, nodesStack, coverageHandler };
        // Iterate on html elements up until we reach and element with coverage handler
        this.findAncestorsCoverageHandler(data);
        // Listening on the stack from top to bottom
        data.coverageHandler.performStartListeningOnNodesStack(nodesStack);
    }
    /**
     * Starts observe DOM changes such as removed/added nodes and/or attributes
     */
    startListeningOnChanges() {
        this.CreateObserverForListeningOnChanges();
        let mutationsOptions = { attributes: true, subtree: true, childList: true };
        this.mutationObserver.observe(document.body, mutationsOptions);
    }
    /**
     * Creating mutation observer for purposes of listening on changes
     */
    CreateObserverForListeningOnChanges() {
        this.lastUniqueId = this.uniqueId;
        this.mutationObserver = new MutationObserver(_.debounce((mutations) => {
            // Are we in a new logical screen?
            if (this.lastUniqueId != this.uniqueId) {
                // New screen. Need to stop current recording, notify that it's a new screen and then restart recording
                this.applicationCoverageHandler.stopListening();
                this.applicationCoverageHandler.startListening();
                //notify application that a page has opened
                this.pageOpened();
                return;
            }
            // GDTEMP: We should do it once all messages have received
            // Check what has changed.
            let structureModified = false;
            let addedNodes = [];
            // Loop on all controls changed in screen
            for (const mutation of mutations) {
                if ((mutation.removedNodes.length > 0 && Array.from(mutation.removedNodes).some((node) => node.nodeType === Node.ELEMENT_NODE && node.nodeName !== "SCRIPT")) ||
                    (mutation.addedNodes.length > 0 && Array.from(mutation.addedNodes).some((node) => node.nodeType === Node.ELEMENT_NODE && node.nodeName !== "SCRIPT"))) {
                    structureModified = true;
                    addedNodes = [...addedNodes, ...Array.from(mutation.addedNodes)];
                }
                //attribute has changed
                //if this element is part of listening info which include this attribute name
                //we will update JBot with the new value
                if (!structureModified && mutation.attributeName) {
                    if (!mutation.attributeName.startsWith(Constants_1.Constants.JBOT_ATTR_PREFIX)) {
                        const $element = $(mutation.target);
                        $element.trigger("attributeChanged", mutation.attributeName);
                    }
                }
                if (structureModified && mutation.removedNodes.length > 0) {
                    for (const node of mutation.removedNodes) {
                        let $element = $(node);
                        $element.trigger("nodeRemoved");
                    }
                }
            }
            if (structureModified) {
                this.applicationCoverageHandler.startListening();
                for (const node of addedNodes) {
                    let $element = $(node);
                    $element.trigger("nodeAdded");
                }
            }
        }, this.waitTimeBeforeDetactChanges));
    }
    /**
     * This method reports that element's attribute has changed to the platform
     * @param listeningElement
     * @param attribute
     * @param value new attribute value
     */
    reportAttributeChanged(listeningElement, attribute, value) {
        let elementPath = listeningElement.path;
        if (listeningElement.lastStatus.has(attribute)) {
            let lastValue = listeningElement.lastStatus.get(attribute);
            // If we already reported and it's false, no need to report
            if (lastValue != value) {
                // Changed
                this.platformDriver.reportChangedElement(elementPath, attribute, value);
                listeningElement.lastStatus.set(attribute, value);
            }
        }
        else {
            // Initial one
            this.platformDriver.reportChangedElement(elementPath, attribute, value);
            listeningElement.lastStatus.set(attribute, value); // Initially set
        }
    }
    /**
     * Request from each frame under this screen to
     * start observe mutations
     */
    startListeningOnChangesInFrames() {
        let $frames = $("iframe,frame");
        $($frames).each((_index, iframe) => {
            let frameGuid = iframe.getAttribute(Constants_1.Constants.ATTR_FRAME_GUID);
            if (frameGuid) {
                iframe.contentWindow.postMessage({
                    message: ChromePlatformDriver_1.default.MESSAGE_START_LISTENING_ON_CHANGES_IN_FRAME,
                    frameGuid: frameGuid,
                }, "*");
            }
        });
    }
    /**
     * Request from each frame under this screen to
     * start observe mutations
     */
    stopListeningInFrames() {
        const $frames = $("iframe,frame");
        $($frames).each((index, iframe) => {
            const $iframe = $(iframe);
            const uniqueId = $iframe.data(Constants_1.Constants.JBOT_UNIQUE_ID_KEY);
            $iframe.offNative(ChromePlatformDriver_1.default.FRAME_LISTENED_ELEMENT_MESSAGE, uniqueId);
            const frameGuid = iframe.getAttribute(Constants_1.Constants.ATTR_FRAME_GUID);
            iframe.contentWindow.postMessage({
                message: ChromePlatformDriver_1.default.MESSAGE_STOP_LISTENING_ON_FRAME,
                frameGuid: frameGuid,
            }, "*");
        });
    }
    startListening() {
        this.startListeningOnChanges();
        this.startListeningOnChangesInFrames();
        return this.returnSuccess();
    }
    stopListening() {
        this.stopListeningOnChanges();
        this.stopListeningInFrames();
        this.removeAllRegisteredEvents();
        this.removeAllCoverageHandlersFromNode();
        return this.returnSuccess("");
    }
    /**
     * Stop listening on changes (mutation observer)
     */
    stopListeningOnChanges() {
        if (this.mutationObserver) {
            this.mutationObserver.disconnect();
            this.mutationObserver = null;
        }
    }
    startCapturing() {
        this.highlightMap = {}; // Initiating the control mapping
        this.inCaptureMode = true;
        this.startCapturingOnScreen();
        // This will loop on children
        let result = this.performStartCapturingOnElementsInScreen();
        log.debug("Capturing was set");
        return result;
    }
    /**
     * Enter into recording mode on the screen and its children
     */
    performStartCapturingOnElementsInScreen() {
        // If we have app sections, lets handle them
        if (this.appSections.length == 0) {
            this.walkOnChildren(document.body, (node) => {
                return this.performStartCapturingOnNode(node);
            });
        }
        else {
            // Enter the recording on the app sections and then on the main section
            for (let i = 0; i < this.appSections.length; i++) {
                let appSection = this.appSections[i];
                if (appSection.isAppSectionAppear()) {
                    appSection.performStartCapturing();
                }
            }
            let $mainSection = this.getMainSection();
            if ($mainSection) {
                this.performStartCapturingOnNode($mainSection[0]);
            }
        }
        return this.returnSuccess();
    }
    /**
     * Start capturing on document body
     */
    startCapturingOnScreen() {
        // The window can also be captured
        let $elem = $(document.body);
        this.registerScreenForCapture(this, $elem, (event) => {
            this.executeStartCapturingClicked(event);
        });
        // Make the window ready for capturing.
        this.startHighlightingOnScreen();
        // For a case of mouse move on the highlighter
        $(document).on(Constants_1.Constants.EVENT_CAPTURE_MOUSE, (event) => {
            this.handleHighlightMouseEvent(event);
        });
        this.highlightObject.setPreventClickEvent(true);
    }
    stopCapturingOnScreen() {
        this.stopHighlightOnScreen();
        $(document).off(Constants_1.Constants.EVENT_CAPTURE_MOUSE);
    }
    stopCapturing() {
        // Remove highlights for capture if exists
        this.removeHighlighter(); // Remove the current highlighted
        this.stopHighlightElementsInScreen();
        this.stopCapturingOnScreen();
        this.stopCapturingOnFrames();
        this.removeAllRegisteredEvents();
        this.removeAllCoverageHandlersFromNode();
        this.inCaptureMode = false;
        log.debug("Capturing was stopped");
        return this.returnSuccess("Capturing stopped");
    }
    stopCapturingOnFrames() {
        const $frames = $("iframe,frame");
        $($frames).each((_index, iframe) => {
            iframe.contentWindow.postMessage({
                message: "stopCapturingOnFrame",
            }, "*");
        });
    }
    /**
     * Stop capturing by removing all elements with Capture Attr.
     */
    stopHighlightElementsInScreen() {
        let $elements = $("[" + Constants_1.Constants.JBOT_HIGHLIGHT_ATTR_ID + "]");
        let self = this;
        $elements.each(function () {
            let $elem = $(this);
            const controlCoverage = self.getCoverageHandlerForNode(this);
            if (self.inCaptureMode || controlCoverage.customCoverageHandler.node.data(Constants_1.Constants.IS_PREVENT_CLICK_ON_ELEMENT)) {
                const uniqueId = $elem.data(Constants_1.Constants.JBOT_UNIQUE_ID_KEY);
                $elem.offNative(Constants_1.Constants.EVENT_OVERLAY_CLICKED, uniqueId);
            }
            // Remove the attributes
            $elem.removeAttr(Constants_1.Constants.JBOT_HIGHLIGHT_ATTR_ID);
        });
    }
    /**
     * Create a selector from this coverage handler to childDomNode
     * @param childDomNode
     * @param useExistingSelector
     * @returns a selector
     */
    createSelectorToChild(childDomNode, useExistingSelector) {
        let partialSelector = this.createSelectorFromParentToChild(document.body, childDomNode);
        let anchorSelector = this.createAnchorSelector(useExistingSelector);
        return this.concatenateSelectorParts(anchorSelector, partialSelector);
    }
    /**
     * Get the path to ourselves
     * @param useExistingSelector
     * @returns $(document.body) by default
     */
    createAnchorSelector(useExistingSelector) {
        return "$(document.body)";
    }
    /**
     * concatenate ourself with the access to the child.
     * @param anchorSelector
     * @param partialSelector
     * @returns
     */
    concatenateSelectorParts(anchorSelector, partialSelector) {
        return `${anchorSelector}.children${partialSelector}`;
    }
    createSelectorFromParentToChild(parentDomNode, elementDomNode) {
        // Create a selector command that finds the element node on parent element.
        // By default we do it by finding the element type and it's index. So, lets walk
        let nodeTagName = elementDomNode.nodeName;
        let indexInParent = 0;
        this.walkOnChildren(parentDomNode, function (node) {
            if (node === elementDomNode) {
                return false; // Stop looping
            }
            else {
                if (node.nodeName === nodeTagName) {
                    indexInParent++;
                }
                return true;
            }
        });
        // Return a JQuery selector based on the index
        return `('${nodeTagName}').eq(${indexInParent})`;
    }
    canAccessDirectly() {
        return true;
    }
    getNode() {
        const selector = this.getSelectorFromRepository();
        if (!selector)
            return this.returnFailure("Selector was not found");
        const selectionCmd = this.createJQuerySelectorCommand(selector);
        const $elements = eval(selectionCmd);
        if ($elements.length === 0) {
            return this.returnFailure(`Selector ${selectionCmd} not found`);
        }
        return this.returnSuccess({ accessResult: $elements });
    }
    /**
     * This method gets the selector part from the field section in the repository
     * @returns selector if a selector exists otherwise false
     */
    getSelectorFromRepository() {
        // Getting our configuration. This is specific for JQuery.
        const config = this.repositoryHandler.config;
        const fields = config.fields;
        // By default we perform get on first field. Other controls can change it.
        const field = fields[0];
        return field.selector;
    }
    createJQuerySelectorCommand(selector) {
        if (selector.startsWith("$"))
            return selector;
        selector = `$${selector}`;
        return selector;
    }
    /**
     * Register screen for highlight
     * @param screenCoverageHandler
     * @param $elem document body
     * @param functionHandler event handler
     */
    registerScreenForCapture(screenCoverageHandler, $elem, functionHandler) {
        // This control wants to handle capture. We add it to the dictionary so we can map it on mouse move and click.
        // Get the key for the dictionary
        let key = this.uniqueId;
        let highlightElementData = new WebHighlightElementData_1.default(screenCoverageHandler, $elem, functionHandler);
        this.registerElementForHighlight(key, highlightElementData, $elem);
    }
    registerControlForHighlight(controlCoverageHandler, $elem, functionHandler) {
        // This control wants to handle capture. We add it to the dictionary so we can map it on mouse move and click.
        // Get the key for the dictionary
        const key = $elem.data(Constants_1.Constants.JBOT_UNIQUE_ID_KEY);
        const highlightElementData = new WebHighlightElementData_1.default(controlCoverageHandler, $elem, functionHandler);
        this.registerElementForHighlight(key, highlightElementData, $elem);
    }
    /**
     * register
     * @param key screen unique id
     * @param highlightElementData
     * @param $elem document body
     */
    registerElementForHighlight(key, highlightElementData, $elem) {
        // We also adding indication on the control that we have highlight on it.
        $elem.attr(Constants_1.Constants.JBOT_HIGHLIGHT_ATTR_ID, key);
        // This control wants to handle capture. We add it to the dictionary so we can map it on mouse move and click.
        this.highlightMap[key] = highlightElementData;
        if (highlightElementData.captureCallback) {
            // Do we have call back in case of capture ? If yes, register for that click
            const uniqueId = $elem.data(Constants_1.Constants.JBOT_UNIQUE_ID_KEY);
            $elem.onNative(Constants_1.Constants.EVENT_OVERLAY_CLICKED, uniqueId, function (event) {
                let functionHandler = highlightElementData.captureCallback;
                if (functionHandler) {
                    log.trace(`Clicked on element with key ${key}`);
                    functionHandler(event);
                }
            });
            $elem.attr(Constants_1.Constants.JBOT_REGISTERED_ATTR, "");
        }
    }
    /**
     * Listen to the mouse move. We will get it also from the controls as it will bubble. However if we open a highlighter, it should not bubble.
     */
    startHighlightingOnScreen() {
        this.highlightObject = new WebHighlight_1.default(this, ControlCoverageHandler_1.default.ELEMENT_HIGHLIGHT_COLOR, document);
        $("body").onNative("mousemove", this.uniqueId, (event) => {
            this.handleMouseMoveOnHighlight(event);
        });
    }
    /**
     * Stops highlight
     */
    stopHighlightOnScreen() {
        $("body").offNative("mousemove", this.uniqueId);
        if (this.highlightObject) {
            this.highlightObject.destroy();
            this.highlightObject = null;
        }
        if (this.snapshotHighlightObject) {
            this.snapshotHighlightObject.destroy();
            this.snapshotHighlightObject = null;
        }
    }
    /**
     * Mouse move event handler
     * @param event mouse move event data
     * @returns
     */
    handleMouseMoveOnHighlight(event) {
        // We received mouse move event directly
        log.trace(`mouse move: ${event.clientX}/${event.clientY}`);
        let highlightElementData;
        let $elem;
        let isElementFound = false;
        // On move, we find the elements where the mouse above them and choose the smallest or last one in the list.
        let lowestElement = this.elementFromPoint(event.clientX, event.clientY);
        if (!lowestElement) {
            // Not on element - so on window
            // log.debug("Highlighter: Element was not found from point");
            highlightElementData = this.highlightMap[this.uniqueId];
            $elem = $(document.body);
        }
        else {
            $elem = $(lowestElement);
            // log.debug("Highlighter: Element was found from point. type is " + lowestElement.tagName);
            if ($elem.prop("class") === "jBotHighlighter") {
                // Make sure we do not receive events on the highlighter itself
                log.trace("Mouse is on highlighter");
                return;
            }
            // If we are inside an iFrame - we should let the iFrame handle it.
            // If we move on an iFrame, we only allow to click on the border. Therefore if we are not on the border, it's same as leaving.
            if (lowestElement.tagName === "IFRAME" || lowestElement.tagName === "FRAME") {
                if (event.offsetX > 1 && event.offsetX < $elem.width() - 2 && event.offsetY > 1 && event.offsetY < $elem.height() - 2) {
                    // We are in the middle of the frame. Remove it.
                    this.removeHighlighter();
                    return;
                }
            }
            while ($elem && $elem.length > 0 && !$elem.is("body")) {
                // All elements which are ready to be captured should have this attribute
                let key = $elem.attr(Constants_1.Constants.JBOT_HIGHLIGHT_ATTR_ID);
                if (key && key.length > 0) {
                    log.trace(`Highlighter:  Element key on move is:${key}`);
                    // Was it registered ?
                    highlightElementData = this.highlightMap[key];
                    if (highlightElementData) {
                        isElementFound = true;
                        break;
                    }
                    log.trace(`Highlighter:  Element with key is not in the map:${key}`);
                }
                else {
                    // log.debug("Highlighter: No key for element. Go to parent.");
                }
                // Not registered - climbing up to parent
                $elem = $elem.parent();
            }
            if (!$elem || $elem.length == 0) {
                log.trace(`Highlighter: Haven't found element to highlight for type ${lowestElement.tagName}`);
                return;
            }
        }
        // Highlight the element
        if (isElementFound) {
            // log.debug(`Highlighter: Highlighting element: ${$elem}`)
            this.highlightElement($elem);
        }
        else {
            // log.debug(`Highlighter: Remove highlighting element: ${$elem}`)
            this.removeHighlighter();
        }
    }
    /**
     * @param x coordinate
     * @param y coordinate
     * @returns the element for the specified x coordinate and the specified y coordinate.
     */
    elementFromPoint(x, y) {
        return document.elementFromPoint(x, y);
    }
    /**
     * Capture mouse move event handler
     * @param event
     * @returns
     */
    handleHighlightMouseEvent(event) {
        // Handle mouse move on the element. The key will identify it
        // See the event created in WebHighlight
        let data = event.detail;
        let key = data.key;
        log.trace(`Received capture mouse event with key ${key}`);
        let highlightElementData = this.highlightMap[key];
        if (!highlightElementData) {
            log.trace(`No capture element data for key ${key}`);
            return;
        }
        let $elem = highlightElementData.$elem;
        // Highlight the element
        log.trace("Highlighting element");
        this.highlightElement($elem);
    }
    /**
     * Add or remove highlight to element
     * @param $highlightedElement
     * @returns
     */
    highlightElement($highlightedElement) {
        // If already highlighted, no need to do again
        log.trace(`In highlightElement: ${$highlightedElement}`);
        if ($highlightedElement) {
            log.trace(`In highlightElement: element exists`);
        }
        if ($highlightedElement && $highlightedElement.attr(Constants_1.Constants.ELEMENT_IS_CURRENTLY_HIGHLIGHTED))
            return;
        log.trace(`In highlightElement: highlightedElement is: ${this.highlightElement.name}`);
        // Remove from current
        this.removeHighlighter();
        // Set the highlighting
        this.addHighlighter($highlightedElement);
        return;
    }
    /**
     * Add highlighter attribute to element
     * @param $elem
     * @returns
     */
    addHighlighter($elem) {
        if (!$elem)
            return;
        this.showHighlighter($elem);
        $elem.attr(Constants_1.Constants.ELEMENT_IS_CURRENTLY_HIGHLIGHTED, "true");
    }
    /**
     * Remove the current highlighted
     */
    removeHighlighter() {
        this.removeHighlightAttribute();
        this.hideHighlighter();
    }
    /**
     * Show red highlight according to show argument
     * @param $elem element to highlight
     * @param show if true show highlight otherwise hide highlight
     */
    highlightForSnapshot($elem, show) {
        if (show) {
            this.hideHighlighter();
            if (!this.snapshotHighlightObject) {
                this.snapshotHighlightObject = new WebHighlight_1.default(this, ControlCoverageHandler_1.default.ELEMENT_SNAPSHOT_COLOR, document);
            }
            this.snapshotHighlightObject.show($elem);
        }
        else {
            if (this.snapshotHighlightObject) {
                this.snapshotHighlightObject.hide();
            }
        }
    }
    /**
     * Remove current highlighted attribute element
     */
    removeHighlightAttribute() {
        let $elem = $("[" + Constants_1.Constants.ELEMENT_IS_CURRENTLY_HIGHLIGHTED + "]");
        $elem.removeAttr(Constants_1.Constants.ELEMENT_IS_CURRENTLY_HIGHLIGHTED);
    }
    /**
     * show highlight around element
     * @param $elem to highlight
     * @returns
     */
    showHighlighter($elem) {
        if ($elem.length === 0)
            return;
        const controlCoverage = this.getCoverageHandlerForNode($elem[0]);
        //Recording mode
        if (!this.inCaptureMode && controlCoverage.customCoverageHandler && (0, TypeGuards_1.isControl)(controlCoverage.customCoverageHandler)) {
            this.highlightObject.setPreventClickEvent(controlCoverage.customCoverageHandler.node.data(Constants_1.Constants.IS_PREVENT_CLICK_ON_ELEMENT));
        }
        let element = $elem[0];
        this.highlightObject.show(element);
    }
    /**
     * hide highlight around element
     * @returns
     */
    hideHighlighter() {
        // Show/move the highlighted rectangle
        if (!this.highlightObject)
            return;
        this.highlightObject.hide();
    }
    /**
     * On a default web screen, which is HTML based, each element decides what to record.
     * Here we walk on the stack and each node decides if to record itself
     * @param nodesStack
     * @returns
     */
    performStartRecordingOnNodesStack(nodesStack) {
        if (nodesStack.length === 0) {
            return this.returnSuccess("");
        }
        let node = nodesStack.pop();
        this.performStartRecordingOnNodeAndStack(node, nodesStack);
    }
    /**
     * On a default web screen, which is HTML based, each element decides what to listen to.
     * Here we walk on the stack and each node decides if it needs to start listening.
     * @param nodesStack
     * @returns
     */
    performStartListeningOnNodesStack(nodesStack) {
        // On a default web screen, which is HTML based, each element decides what to record.
        // Here we walk on the stack and each node decides if to record itself
        if (nodesStack.length === 0) {
            return this.returnSuccess("");
        }
        let node = nodesStack.pop();
        this.performStartListeningOnNodeAndStack(node, nodesStack);
    }
    url() {
        return window.location.href;
    }
    screenTitle() {
        return document.title;
    }
    screenName() {
        // By default, the unique Id in web is the url without all the non alphanumeric characters
        return document.title;
    }
    walkOnChildren(parentNode, func) {
        if (!parentNode) {
            log.trace("walkOnChildren but no parentNode");
            return;
        }
        let node = parentNode.firstChild;
        if (!node) {
            log.trace(`no first child for ${parentNode.nodeName}`);
            return;
        }
        if (node)
            do {
                log.trace(`nodeType= ${node.nodeType}`);
                if (node.nodeType === Node.ELEMENT_NODE) {
                    if (!func(node)) {
                        break;
                    }
                }
            } while ((node = node.nextSibling));
    }
    /**
     * Search and retrieve from memory a coverage handler which was set for this node.
     * @param node - the node we looking to find coverage for. The coverage returned can be from any coverage handler class.
     */
    fetchCoverageHandlerFromNode(node) {
        const uniqueId = $(node).data(Constants_1.Constants.JBOT_UNIQUE_ID_KEY);
        if (!uniqueId) {
            return null;
        }
        return this.fetchCoverageHandlerFromUniqueId(uniqueId);
    }
    /**
     * Remove the coverage handler from memory include coverage attribute from element
     * @param node - This coverage handler node
     */
    removeCoverageHandlerFromNode(node) {
        const uniqueId = $(node).data(Constants_1.Constants.JBOT_UNIQUE_ID_KEY);
        if (!uniqueId) {
            return;
        }
        this.deleteCoverageHandlerForUniqueId(uniqueId);
        node.removeAttribute(Constants_1.Constants.JBOT_COVERAGE_HANDLER_ATTR);
    }
    /**
     * Retrieve a unique id from a given node
     * @param node The node we try to retrieve a unique id from
     */
    getUniqueIdOfNode(node) {
        return null;
    }
    /**
     * This method gets a node and returns it's coverageHandler.
     * @param node - the node to get it's coverage handler
     * @returns the suitable coverageHandler.
     */
    getCoverageHandlerForNode(node) {
        let coverageHandler = this.fetchCoverageHandlerFromNode(node);
        if (coverageHandler) {
            return coverageHandler;
        }
        // Need to try get it from type and factory
        // Get the node type (web type)
        let result = this.getCoverageHandlerByNode(node);
        if (!result.success) {
            return null;
        }
        coverageHandler = result.data.coverageHandler;
        coverageHandler.setNode(node);
        const uniqueId = $(node).data(Constants_1.Constants.JBOT_UNIQUE_ID_KEY);
        coverageHandler.saveCoverageHandlerForUniqueId(uniqueId);
        node.setAttribute(Constants_1.Constants.JBOT_COVERAGE_HANDLER_ATTR, "");
        return coverageHandler;
    }
    /**
     * This method gets a HTMLElement and HTMLElement array and starts the recording process on the
     * nodes in the array.
     * @param node -
     * @param nodesStack
     * @returns true
     */
    performStartRecordingOnNodeAndStack(node, nodesStack) {
        // We have a stack of nodes which we should perform recording on it.
        // Prepare node for recording. Need to find the coverage handler for this node to execute it.
        let coverageHandler = this.getCoverageHandlerForNode(node);
        coverageHandler.performStartRecordingOnNodesStack(nodesStack);
        return true;
    }
    /**
     * This method gets a HTMLElement and HTMLElement array and starts the listening process on the
     * nodes in the array.
     * @param node
     * @param nodesStack
     * @returns
     */
    performStartListeningOnNodeAndStack(node, nodesStack) {
        // We have a stack of nodes which we should perform recording on it.
        // Prepare node for recording. Need to find the coverage handler for this node to execute it.
        let coverageHandler = this.getCoverageHandlerForNode(node);
        coverageHandler.createRepositoryIfNotExists();
        coverageHandler.performStartListeningOnNodesStack(nodesStack);
        return true;
    }
    performStartCapturingOnNode(node) {
        // Prepare node to be captured. Need to find the coverage handler for this node to execute it.
        // Let the coverage prepare for the capture
        let coverageHandler = this.getCoverageHandlerForNode(node);
        if (coverageHandler instanceof WebControlCoverageHandler_1.default) {
            coverageHandler.performStartCapturing();
        }
        else if (coverageHandler instanceof WebScreenCoverageHandler) {
            this.walkOnChildren(node, (childNode) => {
                return coverageHandler.performStartCapturingOnNode(childNode);
            });
        }
        // Return code is important to continue the walking on children
        return true;
    }
    createElementRepositoryNode() {
        let elementNode = super.createElementRepositoryNode();
        elementNode.id = this.uniqueId;
        elementNode.config.url = this.url();
        elementNode.config.fields = []; // Web elements can have multiple fields.
        const field = { selector: "$(document.body)" };
        elementNode.config.fields.push(field);
        elementNode.name = this.screenName();
        return elementNode;
    }
    /**
     * This method validates if the screen and the controls under it exist during execution.
     * @param elementPath - the path of te element to validate
     * @param lAction - the action to execute
     * @returns a GenericResult struct
     */
    async validateScreenAndControls(elementPath, lAction) {
        // Wait for the screen
        let result = this.validateScreen();
        if (!result.success)
            return result;
        // Now validate that the controls (if exist in the path) exists. If not, we will need to wait and try again.
        let elementPathCurrentIndex = elementPath.currentIndex;
        result = await this.execLastNodeOnScreenAsync(elementPath, lAction, true);
        // Restore element path before return or rerun
        elementPath.currentIndex = elementPathCurrentIndex;
        return result;
    }
}
exports.default = WebScreenCoverageHandler;
//# sourceMappingURL=WebScreenCoverageHandler.js.map