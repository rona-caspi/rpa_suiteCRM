"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CoverageHandlerCreator_1 = require("@jacada-jbot/base/include/CoverageHandlers/CoverageHandlerCreator");
const ChromePlatformDriver_1 = require("./ChromePlatformDriver");
const FrameWebControlCoverageHandler_1 = require("../CoverageHandlers/Web/FrameWebControlCoverageHandler");
const Log4jConfig_1 = require("@jacada-jbot/base/include/Utils/Log4jConfig");
const log = Log4jConfig_1.logFactory.getLogger("InboundHandlersFactory");
/**
 * This class handles messages that sent from extension
 */
class InboundHandlersFactory {
    constructor(applicationContext) {
        this.applicationContext = applicationContext;
        /**
         * Chrome extension message event handler
         * @param request message from extension
         * @param sender who send this message
         * @param sendResponse callback function
         */
        this.backgroundMessageHandler = (request, sender, sendResponse) => {
            log.info(`JBot receive: ${request.message}`);
            log.debug(`Request is: ${JSON.stringify(request)}`);
            let handler = this.getHandler(request.message);
            if (!handler) {
                log.error(`Could not find handler for ${request.message}`);
                return;
            }
            if (sendResponse) {
                sendResponse(handler(request));
            }
            else {
                handler(request);
            }
        };
        /**
         * init message handler creates an application object
         * @param request message data: repository, application data, application name and iFrame guid (if exists)
         */
        this.init = (request) => {
            this.applicationContext.appRepositoryNode = request.repositoryNode;
            this.applicationContext.myFrameGuid = request.frameGuid;
            this.applicationContext.applicationData = request.applicationData == undefined ? "{}" : request.applicationData;
            this.applicationContext.applicationName = request.applicationName;
            this.applicationContext.createAppObject();
            this.applicationContext.currentApp = (0, CoverageHandlerCreator_1.getApplicationCoverageHandler)();
            FrameWebControlCoverageHandler_1.default.searchSubApplicationsInRepository(this.applicationContext.currentApp);
        };
        /**
         * Request from current application to start record
         * @param request
         */
        this.startRecording = (request) => {
            this.applicationContext.currentApp.startRecording();
        };
        /**
         * Request from current application to stop record
         * @param request
         */
        this.stopRecording = (request) => {
            this.applicationContext.currentApp.stopRecording();
        };
        /**
         * Request from current application to start capture
         * @param request
         */
        this.startCapturing = (request) => {
            this.applicationContext.currentApp.startCapturing();
        };
        /**
         * Request from current application to stop capture
         * @param request
         */
        this.stopCapturing = (request) => {
            this.applicationContext.currentApp.stopCapturing();
        };
        /**
         * Execution is done first by validation
         * Validate screen and the control for the path
         * @param request
         */
        this.validateElementPath = (request) => {
            let execObj = this.createExecObject(request);
            if (!execObj) {
                return;
            }
            let elementPath = execObj.elementPath;
            let promise = this.applicationContext.currentApp.validateElementPath(elementPath, execObj.executionLogicalAction);
            promise
                .then(function (data) {
                log.debug(`ValidateElementPath result: ${JSON.stringify(data)}`);
                if (this.applicationContext.myFrameGuid) {
                    // We are a frame. Need to notify parent through the driver.
                    let platformDriver = (0, CoverageHandlerCreator_1.getPlatformDriver)();
                    platformDriver.execOnFrameCompleted(data);
                }
                else {
                    // We are main
                    chrome.runtime.sendMessage({
                        service: "elementFound",
                        elementPath: elementPath,
                        found: data.success ? true : false,
                    });
                }
            }.bind(this))
                .catch(() => {
                chrome.runtime.sendMessage({
                    service: "executeActionCompleted",
                    elementPath: elementPath,
                    status: "Failure executing the action",
                });
            });
        };
        /**
         * Execute action asynchronously. After validation that we are in the right place
         * @param request
         */
        this.executeAction = (request) => {
            let execObj = this.createExecObject(request);
            if (!execObj) {
                return;
            }
            let elementPath = execObj.elementPath;
            log.debug(`Execute action path: ' ${elementPath}' on: ${JSON.stringify(request.executionLogicalAction)}`);
            let promise = this.applicationContext.currentApp.executeActionAsync(elementPath, execObj.executionLogicalAction);
            promise
                .then((result) => {
                log.debug(`Execute action result: ${JSON.stringify(result)}`);
                if (this.applicationContext.myFrameGuid) {
                    // We are a frame. Need to notify parent through the driver.
                    let platformDriver = (0, CoverageHandlerCreator_1.getPlatformDriver)();
                    platformDriver.execOnFrameCompleted(result);
                }
                else {
                    // We are main
                    if (result.success) {
                        chrome.runtime.sendMessage({
                            service: "executeActionCompleted",
                            elementPath: elementPath,
                            data: result.data,
                            status: "Success",
                        });
                    }
                    else {
                        chrome.runtime.sendMessage({
                            service: "executeActionCompleted",
                            elementPath: elementPath,
                            status: "Failure executing the action",
                            data: result.data,
                        });
                    }
                }
            })
                .catch((reason) => {
                chrome.runtime.sendMessage({
                    service: "executeActionCompleted",
                    elementPath: elementPath,
                    status: "Failure executing the action",
                    data: reason,
                });
            });
        };
        /**
         * Start listening on top level frame
         * @param request.listeningInfo Elements to listen to
         */
        this.startListening = (request) => {
            let listeningInfo = request.listeningInfo;
            this.applicationContext.currentApp.setListeningInfo(listeningInfo);
            this.applicationContext.currentApp.startListening();
        };
        /**
         *  Start listening on specific element at specific frame
         * @param request.listeningInfo Element to listen to
         */
        this.startListeningElementOnFrame = (request) => {
            this.applicationContext.currentApp.startListeningOnFrameElement(request.listeningInfo);
        };
        /**
         * This method let Background script know that this coverage handler is already loaded
         */
        this.isCoverageLoaded = (request) => {
            return true;
        };
        /**
         * Start listening on changes (mutation observer) in frame
         */
        this.startListeningOnChangesInFrame = () => {
            this.applicationContext.currentApp.startListeningOnFrame();
        };
        /**
         * Stop listening in all frames
         */
        this.stopListening = () => {
            this.applicationContext.currentApp.stopListening();
            this.applicationContext.currentApp.setListeningInfo([]);
        };
        /**
         * Notify application that page has opened -
         * @param request
         */
        this.pageOpened = (request) => {
            this.applicationContext.currentApp.pageOpened();
        };
        /**
         * Update repository tree when we have multiple tabs application during recording/capturing
         * @param request
         */
        this.treeUpdated = (request) => {
            // Need to merge the new things in the tree with the current tree
            if (this.applicationContext.currentApp.repositoryHandler._repository.tree) {
                this.mergeRepositoryObject(this.applicationContext.currentApp.repositoryHandler._repository.tree, request.repositoryNode);
            }
            else {
                this.applicationContext.currentApp.repositoryHandler._repository.tree = request.repositoryNode;
            }
            this.applicationContext.appRepositoryNode = this.applicationContext.currentApp.repositoryHandler._repository.tree;
            // todo - how we handle iFrames? Consult with Lior
        };
        /**
         * We currently DO NOT support multiple instances therefore it must be the same instance
         * @param request
         * @returns true
         */
        this.isSameInstance = (request) => {
            // We currently DO NOT support multiple instances therefore it must be the same instance
            let response = {
                isSameInstance: true,
            };
            return response;
        };
        this.mergeRepositoryObject = (targetNode, sourceNode) => {
            // Why we merge and not just copy ? Because current coverage handler controls are pointing into the repository
            // Please note: We ONLY ADD ELEMENTS. We do not merge them
            for (let key in sourceNode) {
                let newValue = sourceNode[key];
                if (!targetNode[key]) {
                    // Doesn't Exists in new.
                    targetNode[key] = newValue; // Add it.
                    continue;
                }
                if (Array.isArray(newValue)) {
                    this.mergeRepositoryArray(targetNode[key], newValue);
                }
                else if (newValue instanceof Object) {
                    this.mergeRepositoryObject(targetNode[key], newValue);
                }
                else {
                    targetNode[key] = newValue;
                }
            }
        };
        this.mergeRepositoryArray = (targetNode, sourceNode) => {
            for (let newValue of sourceNode) {
                let newValueId = newValue["id"];
                if (!newValueId) {
                    // Without id we can't compare so just add it
                    targetNode.push(newValue); // Add it.
                    continue;
                }
                // Check if we have in the array and element with the same id. We assume inside arrays we have objects with ids
                let prevValues = targetNode.filter((prevValue) => prevValue["id"] == newValueId);
                if (prevValues.length > 0) {
                    // yes- there is an element with same id. lets merge it
                    let prevValue = prevValues[0];
                    this.mergeRepositoryObject(prevValue, newValue);
                }
                else {
                    // This id doesn't exist - push it
                    targetNode.push(newValue); // Add it.
                    continue;
                }
            }
        };
        this.handlers = {};
        this.setHandlers();
        chrome.runtime.onMessage.addListener(this.backgroundMessageHandler);
    }
    /**
     * Set handler to each message type
     */
    setHandlers() {
        this.handlers["init"] = this.init;
        this.handlers["startRecording"] = this.startRecording;
        this.handlers["stopRecording"] = this.stopRecording;
        this.handlers["startCapturing"] = this.startCapturing;
        this.handlers["stopCapturing"] = this.stopCapturing;
        this.handlers["validateElementPath"] = this.validateElementPath;
        this.handlers["executeAction"] = this.executeAction;
        this.handlers["startListening"] = this.startListening;
        this.handlers["stopListening"] = this.stopListening;
        this.handlers["treeUpdated"] = this.treeUpdated;
        this.handlers["isSameInstance"] = this.isSameInstance;
        this.handlers["startListeningElementOnFrame"] = this.startListeningElementOnFrame;
        this.handlers["isCoverageLoaded"] = this.isCoverageLoaded;
        this.handlers[ChromePlatformDriver_1.default.MESSAGE_START_LISTENING_ON_CHANGES_IN_FRAME] = this.startListeningOnChangesInFrame;
        this.handlers["pageOpened"] = this.pageOpened;
    }
    /**
     * Get a handler by key
     * @param Key message's key
     * @returns handler
     */
    getHandler(Key) {
        return this.handlers[Key];
    }
    /**
     * Covert request into ExecObject
     * @param request
     * @returns
     */
    createExecObject(request) {
        var elementPath = request.elementPath;
        if (!elementPath) {
            log.error("No element path in request");
            return null;
        }
        return {
            elementPath: elementPath,
            executionLogicalAction: request.executionLogicalAction,
        };
    }
}
exports.default = InboundHandlersFactory;
//# sourceMappingURL=InboundHandlersFactory.js.map