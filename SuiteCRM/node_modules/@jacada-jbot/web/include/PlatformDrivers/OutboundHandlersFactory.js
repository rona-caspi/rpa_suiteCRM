"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ChromePlatformDriver_1 = require("./ChromePlatformDriver");
const Log4jConfig_1 = require("@jacada-jbot/base/include/Utils/Log4jConfig");
const $ = require("jquery");
const Constants_1 = require("../Model/Constants");
const log = Log4jConfig_1.logFactory.getLogger("OutboundHandlersFactory");
/**
 * This class has set of handlers that related to iFrame
 *
 */
class OutboundHandlersFactory {
    constructor(applicationContext) {
        this.applicationContext = applicationContext;
        /**
         * An inner iFrame report that repository tree was changed,
         * dispatch an event to all iFrames  only relevant frame coverage handle will handle it.
         * @param data
         */
        this.treeChanged = (data) => {
            // The frame below found the path. We should add it to our path. Starting from the iFrame command
            log.trace(`treeChanged: iFrame continue to build repository. Data is: ${JSON.stringify(data)}`);
            // Find all the iFrames in the window and dispatch a message to them.
            const frameTreeChangedEvent = new CustomEvent(ChromePlatformDriver_1.MESSAGE_TREE_CHANGED, {
                detail: {
                    frameGuid: data.frameGuid,
                    applicationHandlerNode: data.applicationHandlerNode
                }
            });
            const $frames = $(`[${Constants_1.Constants.ATTR_FRAME_GUID.toLowerCase()} = ${data.frameGuid}]`);
            $frames[0].dispatchEvent(frameTreeChangedEvent);
        };
        /**
         * Recording has reached an iFrame and ask the extension to tell the Frame to start Record.
         * @param data contains frame guid - iFrame's unique id
         */
        this.startRecordingOnFrame = (data) => {
            log.debug(`startRecordingOnFrame: Data is: ${JSON.stringify(data)}`);
            // 
            chrome.runtime.sendMessage({
                service: "startRecordingOnFrame",
                frameGuid: data.frameGuid
            });
        };
        /**
         * Request from extension to stop recording on specific iFrame
         * @param data contains frame guid - iFrame's unique id
         */
        this.stopRecordingOnFrame = (data) => {
            log.debug(`stopRecordingOnFrame: Data is: ${JSON.stringify(data)}`);
            chrome.runtime.sendMessage({
                service: "stopRecordingOnFrame",
                frameGuid: data.frameGuid
            });
        };
        /**
         * Request from extension to start capture on specific iFrame
         * @param data contains frame guid - iFrame's unique id
         */
        this.startCaptureOnFrame = (data) => {
            log.debug(`startCaptureOnFrame: Data is:${JSON.stringify(data)}`);
            // Capture has reached an iFrame and ask the extension to tell the Frame to start Capture.
            chrome.runtime.sendMessage({
                service: "startCaptureOnFrame",
                frameGuid: data.frameGuid
            });
        };
        /**
         * Stop capturing
         * @param data
         */
        this.stopCapturingOnFrame = (data) => {
            log.debug(`stopCapturing: Data is:${JSON.stringify(data)}`);
            this.applicationContext.currentApp.stopCapturing();
        };
        /**
         * Request from extension to start listening on changes on specific iFrame
         * @param data contains frame guid - iFrame's unique id
         */
        this.startListeningOnChangesInFrame = (data) => {
            log.debug(`startListeningOnChangesInFrame: Data is:${JSON.stringify(data)}`);
            chrome.runtime.sendMessage({
                service: ChromePlatformDriver_1.default.MESSAGE_START_LISTENING_ON_CHANGES_IN_FRAME,
                frameGuid: data.frameGuid
            });
        };
        /**
         * Request from extension to start listening according to listening info on specific iFrame
         * @param data contains frame guid - iFrame's unique id  and listening info
         */
        this.startListeningOnFrame = (data) => {
            log.debug(`startListening: Data is:${JSON.stringify(data)}`);
            chrome.runtime.sendMessage({
                service: "startListeningOnFrame",
                frameGuid: data.frameGuid,
                listeningInfo: data.listeningInfo
            });
        };
        /**
         * Request from extension to stop listening on specific iFrame
         * @param data contains frame guid - iFrame's unique id
         */
        this.stopListeningOnFrame = (data) => {
            log.debug(`stopListening" Data is:${JSON.stringify(data)}`);
            chrome.runtime.sendMessage({
                service: "stopListeningOnFrame",
                frameGuid: data.frameGuid
            });
        };
        /**
         * An inner iFrame report that execution has completed,
         * dispatch an event to all iFrames only relevant frame coverage handle will handle it.
         * @param data
         */
        this.frameExecutedNodeOnScreenCompleted = (data) => {
            // The frame below completed execution. We should notify the iFrame 
            log.debug(`iFrame execution completed: Data is:${JSON.stringify(data)}`);
            // Find all the iFrames in the window and dispatch a message to them.
            const executionOnFrameCompletedEvent = new CustomEvent(ChromePlatformDriver_1.default.FRAME_EXEC_NODE_ON_SCREEN_COMPLETED_MESSAGE, {
                detail: {
                    result: data.result,
                    frameGuid: data.frameGuid
                }
            });
            const $frames = $(`[${Constants_1.Constants.ATTR_FRAME_GUID.toLowerCase()} = ${data.frameGuid}]`);
            $frames[0].dispatchEvent(executionOnFrameCompletedEvent);
        };
        /**
         * An inner iFrame report that element has been captured,
         * dispatch an event to all iFrames only relevant frame coverage handle will handle it.
         * @param data
         */
        this.frameCapturedElement = (data) => {
            // The frame below found the path. We should add it to our path. Starting from the iFrame command
            log.trace(`Frame continue to build capture path: Data is:${JSON.stringify(data)}`);
            // Find all the iFrames in the window and dispatch a message to them.
            let frameCapturedEvent = new CustomEvent(ChromePlatformDriver_1.default.FRAME_CAPTURED_ELEMENT_MESSAGE, {
                detail: {
                    pathId: data.pathId,
                    frameGuid: data.frameGuid,
                    snapshot: data.snapshot,
                    coordinates: data.coordinates
                }
            });
            const $frames = $(`[${Constants_1.Constants.ATTR_FRAME_GUID.toLowerCase()} = ${data.frameGuid}]`);
            $frames[0].dispatchEvent(frameCapturedEvent);
        };
        /**
         * An inner iFrame report that table has been captured,
         * dispatch an event to all iFrames only relevant frame coverage handle will handle it.
         * @param data
         */
        this.frameCapturedTable = (data) => {
            // The frame below found the path. We should add it to our path. Starting from the iFrame command
            log.trace(`Frame continue to build capture path: Data is:${JSON.stringify(data)}`);
            // Find all the iFrames in the window and dispatch a message to them.
            const frameCapturedEvent = new CustomEvent(ChromePlatformDriver_1.default.FRAME_CAPTURED_TABLE_MESSAGE, {
                detail: {
                    pathId: data.pathId,
                    fieldsPathIds: data.fieldsPathIds,
                    frameGuid: data.frameGuid,
                    snapshot: data.snapshot,
                    coordinates: data.coordinates
                }
            });
            const $frames = $(`[${Constants_1.Constants.ATTR_FRAME_GUID.toLowerCase()} = ${data.frameGuid}]`);
            $frames[0].dispatchEvent(frameCapturedEvent);
        };
        /**
         * An inner iFrame report that element has been recorded,
         * dispatch an event to all iFrames only relevant frame coverage handle will handle it.
         * @param data
         */
        this.frameRecordedElement = (data) => {
            // The frame below found the path. We should add it to our path. Starting from the iFrame command
            log.trace(`iFrame continue to build recorded path: Data is:${JSON.stringify(data)}`);
            // Find all the iFrames in the window and dispatch a message to them.
            const frameRecordedEvent = new CustomEvent(ChromePlatformDriver_1.default.FRAME_RECORDED_ELEMENT_MESSAGE, {
                detail: {
                    pathId: data.pathId,
                    logicalAction: data.logicalAction,
                    frameGuid: data.frameGuid,
                    snapshot: data.snapshot,
                    coordinates: data.coordinates
                }
            });
            const $frames = $(`[${Constants_1.Constants.ATTR_FRAME_GUID.toLowerCase()} = ${data.frameGuid}]`);
            $frames[0].dispatchEvent(frameRecordedEvent);
        };
        /**
         * An inner iFrame report that attribute/value has changed,
         * dispatch an event to all iFrames only relevant frame coverage handle will handle it.
         * @param data
         */
        this.frameListenedElement = (data) => {
            log.trace(`iFrame continue to bubbling listened element: Data is:${JSON.stringify(data)}`);
            const frameListenedEvent = new CustomEvent(ChromePlatformDriver_1.default.FRAME_LISTENED_ELEMENT_MESSAGE, {
                detail: {
                    frameGuid: data.frameGuid,
                    pathId: data.pathId,
                    attribute: data.attribute,
                    newValue: data.newValue
                }
            });
            const $frames = $(`[${Constants_1.Constants.ATTR_FRAME_GUID.toLowerCase()} = ${data.frameGuid}]`);
            $frames[0].dispatchEvent(frameListenedEvent);
        };
        /**
         * An inner iFrame report that trigger has fired,
         * dispatch an event to all iFrames only relevant frame coverage handle will handle it.
         * @param data
         */
        this.frameTriggerFired = (data) => {
            log.trace(`iFrame continue to fire trigger : Data is:${JSON.stringify(data)}`);
            // Find all the iFrames in the window and dispatch a message to them.
            const frameTriggerFired = new CustomEvent(ChromePlatformDriver_1.default.FRAME_TRIGGER_FIRED_MESSAGE, {
                detail: {
                    frameGuid: data.frameGuid,
                    pathId: data.pathId,
                    trigger: data.trigger
                }
            });
            const $frames = $(`[${Constants_1.Constants.ATTR_FRAME_GUID.toLowerCase()} = ${data.frameGuid}]`);
            $frames[0].dispatchEvent(frameTriggerFired);
        };
        this.handlers = {};
        this.setHandlers();
    }
    /**
     * Set handler to each message type
     */
    setHandlers() {
        this.handlers["startRecordingOnFrame"] = this.startRecordingOnFrame;
        this.handlers["stopRecordingOnFrame"] = this.stopRecordingOnFrame;
        this.handlers["stopCapturingOnFrame"] = this.stopCapturingOnFrame;
        this.handlers["startCaptureOnFrame"] = this.startCaptureOnFrame;
        this.handlers["startListeningOnFrame"] = this.startListeningOnFrame;
        this.handlers[ChromePlatformDriver_1.default.MESSAGE_STOP_LISTENING_ON_FRAME] = this.stopListeningOnFrame;
        this.handlers["treeChanged"] = this.treeChanged;
        this.handlers["frameExecutedNodeOnScreenCompleted"] = this.frameExecutedNodeOnScreenCompleted;
        this.handlers["frameCapturedElement"] = this.frameCapturedElement;
        this.handlers["frameCapturedTable"] = this.frameCapturedTable;
        this.handlers["frameRecordedElement"] = this.frameRecordedElement;
    }
    /**
     * Get a handler by key
     * @param Key message's key
     * @returns handler
     */
    getHandler(Key) {
        return this[Key];
    }
}
exports.default = OutboundHandlersFactory;
//# sourceMappingURL=OutboundHandlersFactory.js.map