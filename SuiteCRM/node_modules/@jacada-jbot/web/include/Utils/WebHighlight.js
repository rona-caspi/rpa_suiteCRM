"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Log4jConfig_1 = require("@jacada-jbot/base/include/Utils/Log4jConfig");
const Constants_1 = require("../Model/Constants");
const log = Log4jConfig_1.logFactory.getLogger("WebHighlight");
class WebHighlight {
    constructor(screenCoverageHandler, frameColor, ownerDocument = parent.document) {
        this.frameColor = frameColor;
        this.ownerDocument = ownerDocument;
        this.active = false;
        this.screenCoverageHandler = screenCoverageHandler;
        this.ownerDocument = ownerDocument;
        // Get the position type of the body
        let ownerDocumentBody = $(ownerDocument.body);
        this.active = false;
        // If it is relative use the body offset when showing the highlight
        if (ownerDocumentBody.css("position") === "relative") {
            this.bodyOffset = ownerDocumentBody.position();
            if (ownerDocumentBody.css('margin')) {
                this.bodyOffset.top = parseFloat(ownerDocumentBody.css('marginTop'));
                this.bodyOffset.left = parseFloat(ownerDocumentBody.css('marginLeft'));
            }
        }
        else {
            this.bodyOffset = { top: 0, left: 0 };
        }
        this.overlay = this.buildOverlay(frameColor).appendTo(ownerDocumentBody);
    }
    buildOverlay(frameColor) {
        let overlay = $("<div />");
        overlay.prop("class", "jBotHighlighter");
        let self = this;
        overlay.on("click", function () {
            log.debug("Highlighted clicked");
            if (self.target) {
                self.hide();
                let event = new Event(Constants_1.Constants.EVENT_OVERLAY_CLICKED);
                self.target[0].dispatchEvent(event);
            }
        });
        overlay[0].addEventListener("mousemove", function (e) {
            self.emitCaptureMouseEventOnMove(overlay, e);
        });
        overlay[0].addEventListener("mouseleave", function (e) {
            self.emitCaptureMouseEventOnLeave(e);
        });
        overlay.css({
            position: "absolute",
            zIndex: 1000000,
            border: `2px solid ${frameColor}`
        }).hide();
        return overlay;
    }
    emitCaptureMouseEventOnMove(overlay, e) {
        if (!this.active)
            return;
        // If we move on an iFrame, we only allow to click on the border. Therefore if we are not on the border, it'ss ame as leaving.
        if (this.target && (this.target.prop("tagName") === "IFRAME" || this.target.prop("tagName") === "FRAME")) {
            if (e.offsetX > 1 && e.offsetX < this.target.width() - 2 && e.offsetY > 1 && e.offsetY < this.target.height() - 2) {
                // We are in the middle of the frame. Remove it.
                this.screenCoverageHandler.removeHighlightAttribute();
                this.hide();
                return;
            }
        }
        // As we get all the events, we need to omit it to the right control below us. To get it, we need to hide ourselves, find the 
        // control below us and omit a capture event to it.
        overlay.hide();
        let targetControl = document.elementFromPoint(e.clientX, e.clientY);
        if (!targetControl) {
            // Not on element - so on window
            log.debug("Element was not found from point");
        }
        else {
            let $elem = $(targetControl);
            log.debug(`Element was found from point. type is ${targetControl.tagName}`);
            let $prevElem;
            do {
                let key = $elem.attr(Constants_1.Constants.JBOT_HIGHLIGHT_ATTR_ID);
                if (key && key.length > 0) {
                    log.debug(`Element key on move is:${key}`);
                    // Notify window about it
                    let captureEvent = new CustomEvent(Constants_1.Constants.EVENT_CAPTURE_MOUSE, {
                        detail: {
                            key: key,
                            type: "move"
                        }
                    });
                    this.ownerDocument.dispatchEvent(captureEvent);
                    break;
                }
                else {
                    log.debug("No key for element. Go to parent.");
                }
                // Not registered - limbing up to parent
                $prevElem = $elem;
                $elem = $elem.parent();
            } while ($elem && $elem.length > 0 && $prevElem != $elem && !$prevElem.is("body"));
        }
        if (this.active) {
            overlay.show();
        }
    }
    emitCaptureMouseEventOnLeave(e) {
        if (!this.active)
            return;
        // As we get all the events, we need to omit it to the right control below us. To get it, we need to hide ourselves, find the 
        // control below us and omit a capture event to it.
        this.screenCoverageHandler.removeHighlightAttribute();
        this.hide();
        // Now perform the dispatch
        let targetControl = document.elementFromPoint(e.clientX, e.clientY);
        if (targetControl) {
            var captureEvent = new MouseEvent(Constants_1.Constants.EVENT_CAPTURE_MOUSE, {
                clientX: e.clientX,
                clientY: e.clientY,
                screenX: e.pageX,
                screenY: e.pageY
            });
            targetControl.dispatchEvent(captureEvent);
        }
    }
    hideFrameHighlight() {
        if (this.frameElement != null) {
            this.frameElement.css("border-width", this.frameBorderWidth);
            this.frameElement.css("border-style", this.frameBorderStyle);
            this.frameElement.css("border-color", this.frameBorderColor);
            this.frameElement = null;
        }
    }
    show(element) {
        let top, left, width, height;
        if (element) {
            this.target = $(element);
        }
        if (this.target) {
            this.hideFrameHighlight();
            if (this.target.prop("tagName") === "FRAME") {
                this.frameElement = this.target;
                this.frameBorderWidth = this.target.css("border-width");
                this.frameBorderStyle = this.target.css("border-style");
                this.frameBorderColor = this.target.css("border-color");
                this.target.css("border", `2px solid ${this.frameColor}`);
            }
            else {
                let offset = this.target.offset();
                top = offset.top - this.bodyOffset.top;
                left = offset.left - this.bodyOffset.left;
                width = this.target.outerWidth();
                height = this.target.outerHeight();
            }
        }
        else {
            top = 2;
            left = 2;
            width = parent.document.documentElement.clientWidth;
            height = parent.document.documentElement.clientHeight;
        }
        this.active = true;
        this.overlay.css({
            top: top,
            left: left,
            width: width,
            height: height
        }).show();
    }
    ;
    hide() {
        this.active = false;
        this.hideFrameHighlight();
        this.overlay.hide();
    }
    ;
    destroy() {
        this.active = false;
        this.hideFrameHighlight();
        this.overlay.remove();
    }
    ;
    setPreventClickEvent(isPreventClickEvent) {
        this.overlay.css({
            pointerEvents: `${isPreventClickEvent ? "auto" : "none"}`
        });
    }
}
exports.default = WebHighlight;
//# sourceMappingURL=WebHighlight.js.map